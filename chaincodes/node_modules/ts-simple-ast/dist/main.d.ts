import { ts, SyntaxKind, CompilerOptions, EmitHint, ScriptKind, NewLineKind, LanguageVariant, ScriptTarget, TypeFlags, ObjectFlags, SymbolFlags, TypeFormatFlags, DiagnosticCategory, EditorSettings, ModuleResolutionKind } from "./typescript/typescript";
import { CodeBlockWriter } from "./codeBlockWriter/code-block-writer";

export declare type Constructor<T> = new (...args: any[]) => T;

export declare type WriterFunction = (writer: CodeBlockWriter) => void;

/**
 * Project that holds source files.
 */
export declare class Project {
    /**
     * Initializes a new instance.
     * @param options - Optional options.
     * @param fileSystem - Optional file system host. Useful for mocking access to the file system.
     */
    constructor(options?: Options, fileSystem?: FileSystemHost);
    /** Gets the manipulation settings. */
    readonly manipulationSettings: ManipulationSettingsContainer;
    /** Gets the compiler options for modification. */
    readonly compilerOptions: CompilerOptionsContainer;
    /**
     * Adds an existing directory from the path or returns undefined if it doesn't exist.
     *
     * Will return the directory if it was already added.
     * @param dirPath - Path to add the directory at.
     * @param options - Options.
     */
    addExistingDirectoryIfExists(dirPath: string, options?: DirectoryAddOptions): Directory | undefined;
    /**
     * Adds an existing directory from the path or throws if it doesn't exist.
     *
     * Will return the directory if it was already added.
     * @param dirPath - Path to add the directory at.
     * @param options - Options.
     * @throws DirectoryNotFoundError when the directory does not exist.
     */
    addExistingDirectory(dirPath: string, options?: DirectoryAddOptions): Directory;
    /**
     * Creates a directory at the specified path.
     * @param dirPath - Path to create the directory at.
     */
    createDirectory(dirPath: string): Directory;
    /**
     * Gets a directory by the specified path or throws if it doesn't exist.
     * @param dirPath - Path to create the directory at.
     */
    getDirectoryOrThrow(dirPath: string): Directory;
    /**
     * Gets a directory by the specified path or returns undefined if it doesn't exist.
     * @param dirPath - Directory path.
     */
    getDirectory(dirPath: string): Directory | undefined;
    /**
     * Gets all the directories.
     */
    getDirectories(): Directory[];
    /**
     * Gets the directories without a parent.
     */
    getRootDirectories(): Directory[];
    /**
     * Add source files based on a file glob.
     * @param fileGlobs - File glob to add files based on.
     * @param options - Options for adding the source file.
     * @returns The matched source files.
     */
    addExistingSourceFiles(fileGlob: string, options?: SourceFileAddOptions): SourceFile[];
    /**
     * Add source files based on file globs.
     * @param fileGlobs - File globs to add files based on.
     * @param options - Options for adding the source file.
     * @returns The matched source files.
     */
    addExistingSourceFiles(fileGlobs: string[], options?: SourceFileAddOptions): SourceFile[];
    /**
     * Adds a source file from a file path if it exists or returns undefined.
     *
     * Will return the source file if it was already added.
     * @param filePath - File path to get the file from.
     * @param options - Options for adding the source file.
     */
    addExistingSourceFileIfExists(filePath: string, options?: SourceFileAddOptions): SourceFile | undefined;
    /**
     * Adds an existing source file from a file path or throws if it doesn't exist.
     *
     * Will return the source file if it was already added.
     * @param filePath - File path to get the file from.
     * @param options - Options for adding the source file.
     * @throws FileNotFoundError when the file is not found.
     */
    addExistingSourceFile(filePath: string, options?: SourceFileAddOptions): SourceFile;
    /**
     * Adds all the source files from the specified tsconfig.json.
     *
     * Note that this is done by default when specifying a tsconfig file in the constructor and not explicitly setting the
     * addFilesFromTsConfig option to false.
     * @param tsConfigFilePath - File path to the tsconfig.json file.
     * @param options - Options for adding the source file.
     */
    addSourceFilesFromTsConfig(tsConfigFilePath: string, options?: SourceFileAddOptions): SourceFile[];
    /**
     * Creates a source file at the specified file path.
     *
     * Note: The file will not be created and saved to the file system until .save() is called on the source file.
     * @param filePath - File path of the source file.
     * @throws - InvalidOperationError if a source file already exists at the provided file path.
     */
    createSourceFile(filePath: string): SourceFile;
    /**
     * Creates a source file at the specified file path with the specified text.
     *
     * Note: The file will not be created and saved to the file system until .save() is called on the source file.
     * @param filePath - File path of the source file.
     * @param sourceFileText - Text of the source file.
     * @param options - Options.
     * @throws - InvalidOperationError if a source file already exists at the provided file path.
     */
    createSourceFile(filePath: string, sourceFileText: string, options?: SourceFileCreateOptions): SourceFile;
    /**
     * Creates a source file at the specified file path with the specified text.
     *
     * Note: The file will not be created and saved to the file system until .save() is called on the source file.
     * @param filePath - File path of the source file.
     * @param structure - Structure that represents the source file.
     * @param options - Options.
     * @throws - InvalidOperationError if a source file already exists at the provided file path.
     */
    createSourceFile(filePath: string, structure: SourceFileStructure, options?: SourceFileCreateOptions): SourceFile;
    /**
     * Removes a source file from the AST.
     * @param sourceFile - Source file to remove.
     * @returns True if removed.
     */
    removeSourceFile(sourceFile: SourceFile): boolean;
    /**
     * Gets a source file by a file name or file path. Throws an error if it doesn't exist.
     * @param fileNameOrPath - File name or path that the path could end with or equal.
     */
    getSourceFileOrThrow(fileNameOrPath: string): SourceFile;
    /**
     * Gets a source file by a search function. Throws an erorr if it doesn't exist.
     * @param searchFunction - Search function.
     */
    getSourceFileOrThrow(searchFunction: (file: SourceFile) => boolean): SourceFile;
    /**
     * Gets a source file by a file name or file path. Returns undefined if none exists.
     * @param fileNameOrPath - File name or path that the path could end with or equal.
     */
    getSourceFile(fileNameOrPath: string): SourceFile | undefined;
    /**
     * Gets a source file by a search function. Returns undefined if none exists.
     * @param searchFunction - Search function.
     */
    getSourceFile(searchFunction: (file: SourceFile) => boolean): SourceFile | undefined;
    /**
     * Gets all the source files contained in the compiler wrapper.
     * @param globPattern - Glob pattern for filtering out the source files.
     */
    getSourceFiles(): SourceFile[];
    /**
     * Gets all the source files contained in the compiler wrapper that match a pattern.
     * @param globPattern - Glob pattern for filtering out the source files.
     */
    getSourceFiles(globPattern: string): SourceFile[];
    /**
     * Gets all the source files contained in the compiler wrapper that match the passed in patterns.
     * @param globPatterns - Glob patterns for filtering out the source files.
     */
    getSourceFiles(globPatterns: string[]): SourceFile[];
    /**
     * Saves all the unsaved source files to the file system and deletes all deleted files.
     */
    save(): Promise<void>;
    /**
     * Synchronously saves all the unsaved source files to the file system and deletes all deleted files.
     *
     * Remarks: This might be very slow compared to the asynchronous version if there are a lot of files.
     */
    saveSync(): void;
    /**
     * Enables logging to the console.
     * @param enabled - Enabled.
     */
    enableLogging(enabled?: boolean): void;
    private getUnsavedSourceFiles();
    /**
     * Gets the compiler diagnostics.
     */
    getDiagnostics(): Diagnostic[];
    /**
     * Gets the pre-emit diagnostics.
     */
    getPreEmitDiagnostics(): Diagnostic[];
    /**
     * Gets the language service.
     */
    getLanguageService(): LanguageService;
    /**
     * Gets the program.
     */
    getProgram(): Program;
    /**
     * Gets the type checker.
     */
    getTypeChecker(): TypeChecker;
    /**
     * Gets the file system.
     */
    getFileSystem(): FileSystemHost;
    /**
     * Emits all the source files.
     * @param emitOptions - Optional emit options.
     */
    emit(emitOptions?: EmitOptions): EmitResult;
    /**
     * Gets the compiler options.
     */
    getCompilerOptions(): CompilerOptions;
    /**
     * Creates a writer with the current manipulation settings.
     * @remarks Generally it's best to use a provided writer, but this may be useful in some scenarios.
     */
    createWriter(): CodeBlockWriter;
    /**
     * Forgets the nodes created in the scope of the passed in block.
     *
     * This is an advanced method that can be used to easily "forget" all the nodes created within the scope of the block.
     * @param block - Block of code to run.
     */
    forgetNodesCreatedInBlock(block: (remember: (...node: Node[]) => void) => void): void;
    /**
     * Forgets the nodes created in the scope of the passed in block asynchronously.
     *
     * This is an advanced method that can be used to easily "forget" all the nodes created within the scope of the block.
     * @param block - Block of code to run.
     */
    forgetNodesCreatedInBlock(block: (remember: (...node: Node[]) => void) => Promise<void>): void;
}
export default Project;

export interface Options {
    /** Compiler options */
    compilerOptions?: CompilerOptions;
    /** File path to the tsconfig.json file */
    tsConfigFilePath?: string;
    /** Whether to add the source files from the specified tsconfig.json or not. Defaults to true. */
    addFilesFromTsConfig?: boolean;
    /** Manipulation settings */
    manipulationSettings?: Partial<ManipulationSettings>;
    /** Whether to use a virtual file system. */
    useVirtualFileSystem?: boolean;
}

export interface SourceFileCreateOptions extends SourceFileAddOptions {
    overwrite?: boolean;
}

export interface SourceFileAddOptions {
    languageVersion?: ScriptTarget;
}
export interface FileSystemHost {
    delete(path: string): Promise<void>;
    deleteSync(path: string): void;
    readDirSync(dirPath: string): string[];
    readFile(filePath: string, encoding?: string): Promise<string>;
    readFileSync(filePath: string, encoding?: string): string;
    writeFile(filePath: string, fileText: string): Promise<void>;
    writeFileSync(filePath: string, fileText: string): void;
    mkdir(dirPath: string): Promise<void>;
    mkdirSync(dirPath: string): void;
    move(srcPath: string, destPath: string): Promise<void>;
    moveSync(srcPath: string, destPath: string): void;
    copy(srcPath: string, destPath: string): Promise<void>;
    copySync(srcPath: string, destPath: string): void;
    fileExists(filePath: string): Promise<boolean>;
    fileExistsSync(filePath: string): boolean;
    directoryExists(dirPath: string): Promise<boolean>;
    directoryExistsSync(dirPath: string): boolean;
    getCurrentDirectory(): string;
    glob(patterns: string[]): string[];
}

export declare class Directory {
    private _global;
    private _path;
    private _pathParts;
    /**
     * Checks if this directory is an ancestor of the provided directory.
     * @param possibleDescendant - Directory or source file that's a possible descendant.
     */
    isAncestorOf(possibleDescendant: Directory | SourceFile): boolean;
    /**
     * Checks if this directory is a descendant of the provided directory.
     * @param possibleAncestor - Directory or source file that's a possible ancestor.
     */
    isDescendantOf(possibleAncestor: Directory): boolean;
    /**
     * Gets the path to the directory.
     */
    getPath(): string;
    /**
     * Gets the directory path's base name.
     */
    getBaseName(): string;
    /**
     * Gets the parent directory or throws if it doesn't exist or was never added to the AST.
     */
    getParentOrThrow(): Directory;
    /**
     * Gets the parent directory if it exists and was added to the AST.
     */
    getParent(): Directory | undefined;
    /**
     * Gets a child directory with the specified path or throws if not found.
     * @param path - Relative path from this directory or absolute path.
     */
    getDirectoryOrThrow(path: string): Directory;
    /**
     * Gets a child directory by the specified condition or throws if not found.
     * @param condition - Condition to check the directory with.
     */
    getDirectoryOrThrow(condition: (directory: Directory) => boolean): Directory;
    /**
     * Gets a directory with the specified path or undefined if not found.
     * @param path - Relative path from this directory or absolute path.
     */
    getDirectory(path: string): Directory | undefined;
    /**
     * Gets a child directory by the specified condition or undefined if not found.
     * @param condition - Condition to check the directory with.
     */
    getDirectory(condition: (directory: Directory) => boolean): Directory | undefined;
    /**
     * Gets a child source file with the specified path or throws if not found.
     * @param path - Relative or absolute path to the file.
     */
    getSourceFileOrThrow(path: string): SourceFile;
    /**
     * Gets a child source file by the specified condition or throws if not found.
     * @param condition - Condition to check the source file with.
     */
    getSourceFileOrThrow(condition: (sourceFile: SourceFile) => boolean): SourceFile;
    /**
     * Gets a child source file with the specified path or undefined if not found.
     * @param path - Relative or absolute path to the file.
     */
    getSourceFile(path: string): SourceFile | undefined;
    /**
     * Gets a child source file by the specified condition or undefined if not found.
     * @param condition - Condition to check the source file with.
     */
    getSourceFile(condition: (sourceFile: SourceFile) => boolean): SourceFile | undefined;
    /**
     * Gets the child directories.
     */
    getDirectories(): Directory[];
    /**
     * Gets the source files within this directory.
     */
    getSourceFiles(): SourceFile[];
    /**
     * Gets the source files in the current directory and all the descendant directories.
     */
    getDescendantSourceFiles(): SourceFile[];
    /**
     * Gets the descendant directories.
     */
    getDescendantDirectories(): Directory[];
    /**
     * Adds an existing directory to the AST from the relative path or directory name, or returns undefined if it doesn't exist.
     *
     * Will return the directory if it was already added.
     * @param dirPath - Directory name or path to the directory that should be added.
     * @param options - Options.
     */
    addExistingDirectoryIfExists(dirPath: string, options?: DirectoryAddOptions): Directory | undefined;
    /**
     * Adds an existing directory to the AST from the relative path or directory name, or throws if it doesn't exist.
     *
     * Will return the directory if it was already added.
     * @param dirPath - Directory name or path to the directory that should be added.
     * @throws DirectoryNotFoundError if the directory does not exist.
     */
    addExistingDirectory(dirPath: string, options?: DirectoryAddOptions): Directory;
    /**
     * Creates a directory if it doesn't exist.
     * @param dirPath - Relative or absolute path to the directory that should be created.
     */
    createDirectory(dirPath: string): Directory;
    /**
     * Creates a source file in the AST, relative to this directory.
     *
     * Note: The file will not be created and saved to the file system until .save() is called on the source file.
     * @param relativeFilePath - Relative file path of the source file to create.
     * @throws - InvalidOperationError if a source file already exists at the provided file name.
     */
    createSourceFile(relativeFilePath: string): SourceFile;
    /**
     * Creates a source file in the AST, relative to this directory.
     *
     * Note: The file will not be created and saved to the file system until .save() is called on the source file.
     * @param relativeFilePath - Relative file path of the source file to create.
     * @param sourceFileText - Text of the source file.
     * @param options - Options.
     * @throws - InvalidOperationError if a source file already exists at the provided file name.
     */
    createSourceFile(relativeFilePath: string, sourceFileText: string, options?: SourceFileCreateOptions): SourceFile;
    /**
     * Creates a source file in the AST, relative to this directory.
     *
     * Note: The file will not be created and saved to the file system until .save() is called on the source file.
     * @param relativeFilePath - Relative file path of the source file to create.
     * @param structure - Structure that represents the source file.
     * @param options - Options.
     * @throws - InvalidOperationError if a source file already exists at the provided file name.
     */
    createSourceFile(relativeFilePath: string, structure: SourceFileStructure, options?: SourceFileCreateOptions): SourceFile;
    /**
     * Adds an existing source file to the AST, relative to this directory, or returns undefined.
     *
     * Will return the source file if it was already added.
     * @param relativeFilePath - Relative file path to add.
     * @param options - Options for adding the source file.
     */
    addExistingSourceFileIfExists(relativeFilePath: string, options?: SourceFileAddOptions): SourceFile | undefined;
    /**
     * Adds an existing source file to the AST, relative to this directory, or throws if it doesn't exist.
     *
     * Will return the source file if it was already added.
     * @param relativeFilePath - Relative file path to add.
     * @param options - Options for adding the source file.
     * @throws FileNotFoundError when the file doesn't exist.
     */
    addExistingSourceFile(relativeFilePath: string, options?: SourceFileAddOptions): SourceFile;
    /**
     * Emits the files in the directory.
     * @param options - Options for emitting.
     */
    emit(options?: {
        emitOnlyDtsFiles?: boolean;
        outDir?: string;
        declarationDir?: string;
    }): Promise<DirectoryEmitResult>;
    /**
     * Emits the files in the directory synchronously.
     *
     * Remarks: This might be very slow compared to the asynchronous version if there are a lot of files.
     * @param options - Options for emitting.
     */
    emitSync(options?: {
        emitOnlyDtsFiles?: boolean;
        outDir?: string;
        declarationDir?: string;
    }): DirectoryEmitResult;
    private _emitInternal(options?);
    /**
     * Copies a directory to a new directory.
     * @param relativeOrAbsolutePath - The relative or absolute path to the new directory.
     * @param options - Options.
     * @returns The directory the copy was made to.
     */
    copy(relativeOrAbsolutePath: string, options?: DirectoryCopyOptions): Directory;
    /**
     * Immediately copies the directory to the specified path asynchronously.
     * @param relativeOrAbsolutePath - Directory path as an absolute or relative path.
     * @param options - Options for moving the directory.
     * @remarks If includeTrackedFiles is true, then it will execute the pending operations in the current directory.
     */
    copyImmediately(relativeOrAbsolutePath: string, options?: DirectoryCopyOptions): Promise<Directory>;
    /**
     * Immediately copies the directory to the specified path synchronously.
     * @param relativeOrAbsolutePath - Directory path as an absolute or relative path.
     * @param options - Options for moving the directory.
     * @remarks If includeTrackedFiles is true, then it will execute the pending operations in the current directory.
     */
    copyImmediatelySync(relativeOrAbsolutePath: string, options?: DirectoryCopyOptions): Directory;
    /**
     * Moves the directory to a new path.
     * @param relativeOrAbsolutePath - Directory path as an absolute or relative path.
     * @param options - Options for moving the directory.
     */
    move(relativeOrAbsolutePath: string, options?: DirectoryMoveOptions): this;
    /**
     * Immediately moves the directory to a new path asynchronously.
     * @param relativeOrAbsolutePath - Directory path as an absolute or relative path.
     * @param options - Options for moving the directory.
     */
    moveImmediately(relativeOrAbsolutePath: string, options?: DirectoryMoveOptions): Promise<this>;
    /**
     * Immediately moves the directory to a new path synchronously.
     * @param relativeOrAbsolutePath - Directory path as an absolute or relative path.
     * @param options - Options for moving the directory.
     */
    moveImmediatelySync(relativeOrAbsolutePath: string, options?: DirectoryMoveOptions): this;
    /**
     * Queues a deletion of the directory to the file system.
     *
     * The directory will be deleted when calling ast.save(). If you wish to delete the file immediately, then use deleteImmediately().
     */
    delete(): void;
    /**
     * Asyncronously deletes the directory and all its descendants from the file system.
     */
    deleteImmediately(): Promise<void>;
    /**
     * Synchronously deletes the directory and all its descendants from the file system.
     */
    deleteImmediatelySync(): void;
    /**
     * Forgets the directory and all its descendants from the Project.
     *
     * Note: Does not delete the directory from the file system.
     */
    forget(): void;
    /**
     * Asynchronously saves the directory and all the unsaved source files to the disk.
     */
    save(): Promise<void>;
    /**
     * Synchronously saves the directory and all the unsaved source files to the disk.
     */
    saveSync(): void;
    /**
     * Gets the relative path to another source file.
     * @param sourceFile - Source file.
     */
    getRelativePathTo(sourceFile: SourceFile): string;
    /**
     * Gets the relative path to another directory.
     * @param directory - Directory.
     */
    getRelativePathTo(directory: Directory): string;
    /**
     * Gets the relative path to the specified source file as a module specifier.
     * @param sourceFile - Source file.
     */
    getRelativePathAsModuleSpecifierTo(sourceFile: SourceFile): string;
    /**
     * Gets the relative path to the specified directory as a module specifier.
     * @param directory - Directory.
     */
    getRelativePathAsModuleSpecifierTo(directory: Directory): string;
    /**
     * Gets if the directory was forgotten.
     */
    wasForgotten(): boolean;
}
export declare class DirectoryEmitResult {
    private readonly _emitSkipped;
    private readonly _outputFilePaths;
    /**
     * Gets if the emit was skipped.
     */
    getEmitSkipped(): boolean;
    /**
     * Gets the output file paths.
     */
    getOutputFilePaths(): string[];
}

export interface DirectoryAddOptions {
    /**
     * Whether to also recursively add all the directory's descendant directories.
     * @remarks Defaults to false.
     */
    recursive?: boolean;
}

export interface DirectoryCopyOptions extends SourceFileCopyOptions {
    /**
     * Includes all the files in the directory and sub-directory when copying.
     * @remarks - Defaults to true.
     */
    includeUntrackedFiles?: boolean;
}

export interface DirectoryMoveOptions extends SourceFileMoveOptions {
}

/**
 * Creates a wrapped node from a compiler node.
 * @param node - Node to create a wrapped node from.
 * @param info - Info for creating the wrapped node.
 */
export declare function createWrappedNode<T extends ts.Node = ts.Node>(node: T, opts?: CreateWrappedNodeOptions): Node<T>;

export interface CreateWrappedNodeOptions {
    /**
     * Compiler options.
     */
    compilerOptions?: CompilerOptions;
    /**
     * Optional source file of the node. Will make it not bother going up the tree to find the source file.
     */
    sourceFile?: ts.SourceFile;
    /**
     * Type checker.
     */
    typeChecker?: ts.TypeChecker;
}

/**
 * Gets the compiler options from a specified tsconfig.json
 * @param filePath - File path to the tsconfig.json.
 * @param options - Options.
 */
export declare function getCompilerOptionsFromTsConfig(filePath: string, options?: CompilerOptionsFromTsConfigOptions): CompilerOptionsFromTsConfigResult;

export interface CompilerOptionsFromTsConfigOptions {
    encoding?: string;
    fileSystem?: FileSystemHost;
}

export interface CompilerOptionsFromTsConfigResult {
    options: CompilerOptions;
    errors: Diagnostic[];
}

/**
 * Prints the provided node using the compiler's printer.
 * @param node - Compiler node.
 * @param options - Options.
 */
export declare function printNode(node: ts.Node, options?: PrintNodeOptions): string;

/**
 * Prints the provided node using the compiler's printer.
 * @param node - Compiler node.
 * @param sourceFile - Compiler source file.
 * @param options - Options.
 */
export declare function printNode(node: ts.Node, sourceFile: ts.SourceFile, options?: PrintNodeOptions): string;

/**
 * Options for printing a node.
 */
export interface PrintNodeOptions {
    /**
     * Whether to remove comments or not.
     */
    removeComments?: boolean;
    /**
     * New line kind.
     *
     * Defaults to line feed.
     */
    newLineKind?: NewLineKind;
    /**
     * From the compiler api: "A value indicating the purpose of a node. This is primarily used to
     * distinguish between an `Identifier` used in an expression position, versus an
     * `Identifier` used as an `IdentifierName` as part of a declaration. For most nodes you
     * should just pass `Unspecified`."
     *
     * Defaults to `Unspecified`.
     */
    emitHint?: EmitHint;
    /**
     * The script kind.
     *
     * Defaults to TSX. This is only useful when not using a wrapped node and not providing a source file.
     */
    scriptKind?: ScriptKind;
}

/**
 * Type guards for checking the type of a node.
 */
export declare class TypeGuards {
    private constructor();
    /**
     * Gets if the node has an expression.
     * @param node - Node to check.
     */
    static hasExpression(node: Node): node is Node & {
        getExpression(): Expression;
    };
    /**
     * Gets if the node has a name.
     * @param node - Node to check.
     */
    static hasName(node: Node): node is Node & {
        getName(): string;
    };
    /**
     * Gets if the node has a body.
     * @param node - Node to check.
     */
    static hasBody(node: Node): node is Node & {
        getBody(): Node;
    };
    /**
     * Gets if the node is an AbstractableNode.
     * @param node - Node to check.
     */
    static isAbstractableNode(node: Node): node is AbstractableNode & Node;
    /**
     * Gets if the node is an AmbientableNode.
     * @param node - Node to check.
     */
    static isAmbientableNode(node: Node): node is AmbientableNode & Node;
    /**
     * Gets if the node is an AnyKeyword.
     * @param node - Node to check.
     */
    static isAnyKeyword(node: Node): node is Expression;
    /**
     * Gets if the node is an ArgumentedNode.
     * @param node - Node to check.
     */
    static isArgumentedNode(node: Node): node is ArgumentedNode & Node;
    /**
     * Gets if the node is an ArrayLiteralExpression.
     * @param node - Node to check.
     */
    static isArrayLiteralExpression(node: Node): node is ArrayLiteralExpression;
    /**
     * Gets if the node is an ArrayTypeNode.
     * @param node - Node to check.
     */
    static isArrayTypeNode(node: Node): node is ArrayTypeNode;
    /**
     * Gets if the node is an ArrowFunction.
     * @param node - Node to check.
     */
    static isArrowFunction(node: Node): node is ArrowFunction;
    /**
     * Gets if the node is an AsExpression.
     * @param node - Node to check.
     */
    static isAsExpression(node: Node): node is AsExpression;
    /**
     * Gets if the node is an AsyncableNode.
     * @param node - Node to check.
     */
    static isAsyncableNode(node: Node): node is AsyncableNode & Node;
    /**
     * Gets if the node is an AwaitExpression.
     * @param node - Node to check.
     */
    static isAwaitExpression(node: Node): node is AwaitExpression;
    /**
     * Gets if the node is an AwaitableNode.
     * @param node - Node to check.
     */
    static isAwaitableNode(node: Node): node is AwaitableNode & Node;
    /**
     * Gets if the node is a BinaryExpression.
     * @param node - Node to check.
     */
    static isBinaryExpression(node: Node): node is BinaryExpression;
    /**
     * Gets if the node is a BindingNamedNode.
     * @param node - Node to check.
     */
    static isBindingNamedNode(node: Node): node is BindingNamedNode & Node;
    /**
     * Gets if the node is a Block.
     * @param node - Node to check.
     */
    static isBlock(node: Node): node is Block;
    /**
     * Gets if the node is a BodiedNode.
     * @param node - Node to check.
     */
    static isBodiedNode(node: Node): node is BodiedNode & Node;
    /**
     * Gets if the node is a BodyableNode.
     * @param node - Node to check.
     */
    static isBodyableNode(node: Node): node is BodyableNode & Node;
    /**
     * Gets if the node is a BooleanKeyword.
     * @param node - Node to check.
     */
    static isBooleanKeyword(node: Node): node is Expression;
    /**
     * Gets if the node is a BooleanLiteral.
     * @param node - Node to check.
     */
    static isBooleanLiteral(node: Node): node is BooleanLiteral;
    /**
     * Gets if the node is a BreakStatement.
     * @param node - Node to check.
     */
    static isBreakStatement(node: Node): node is BreakStatement;
    /**
     * Gets if the node is a CallExpression.
     * @param node - Node to check.
     */
    static isCallExpression(node: Node): node is CallExpression;
    /**
     * Gets if the node is a CallSignatureDeclaration.
     * @param node - Node to check.
     */
    static isCallSignatureDeclaration(node: Node): node is CallSignatureDeclaration;
    /**
     * Gets if the node is a CaseBlock.
     * @param node - Node to check.
     */
    static isCaseBlock(node: Node): node is CaseBlock;
    /**
     * Gets if the node is a CaseClause.
     * @param node - Node to check.
     */
    static isCaseClause(node: Node): node is CaseClause;
    /**
     * Gets if the node is a CatchClause.
     * @param node - Node to check.
     */
    static isCatchClause(node: Node): node is CatchClause;
    /**
     * Gets if the node is a ChildOrderableNode.
     * @param node - Node to check.
     */
    static isChildOrderableNode(node: Node): node is ChildOrderableNode & Node;
    /**
     * Gets if the node is a ClassDeclaration.
     * @param node - Node to check.
     */
    static isClassDeclaration(node: Node): node is ClassDeclaration;
    /**
     * Gets if the node is a CommaListExpression.
     * @param node - Node to check.
     */
    static isCommaListExpression(node: Node): node is CommaListExpression;
    /**
     * Gets if the node is a ComputedPropertyName.
     * @param node - Node to check.
     */
    static isComputedPropertyName(node: Node): node is ComputedPropertyName;
    /**
     * Gets if the node is a ConditionalExpression.
     * @param node - Node to check.
     */
    static isConditionalExpression(node: Node): node is ConditionalExpression;
    /**
     * Gets if the node is a ConstructSignatureDeclaration.
     * @param node - Node to check.
     */
    static isConstructSignatureDeclaration(node: Node): node is ConstructSignatureDeclaration;
    /**
     * Gets if the node is a ConstructorDeclaration.
     * @param node - Node to check.
     */
    static isConstructorDeclaration(node: Node): node is ConstructorDeclaration;
    /**
     * Gets if the node is a ConstructorTypeNode.
     * @param node - Node to check.
     */
    static isConstructorTypeNode(node: Node): node is ConstructorTypeNode;
    /**
     * Gets if the node is a ContinueStatement.
     * @param node - Node to check.
     */
    static isContinueStatement(node: Node): node is ContinueStatement;
    /**
     * Gets if the node is a DebuggerStatement.
     * @param node - Node to check.
     */
    static isDebuggerStatement(node: Node): node is DebuggerStatement;
    /**
     * Gets if the node is a DeclarationNamedNode.
     * @param node - Node to check.
     */
    static isDeclarationNamedNode(node: Node): node is DeclarationNamedNode & Node;
    /**
     * Gets if the node is a DecoratableNode.
     * @param node - Node to check.
     */
    static isDecoratableNode(node: Node): node is DecoratableNode & Node;
    /**
     * Gets if the node is a Decorator.
     * @param node - Node to check.
     */
    static isDecorator(node: Node): node is Decorator;
    /**
     * Gets if the node is a DefaultClause.
     * @param node - Node to check.
     */
    static isDefaultClause(node: Node): node is DefaultClause;
    /**
     * Gets if the node is a DeleteExpression.
     * @param node - Node to check.
     */
    static isDeleteExpression(node: Node): node is DeleteExpression;
    /**
     * Gets if the node is a DoStatement.
     * @param node - Node to check.
     */
    static isDoStatement(node: Node): node is DoStatement;
    /**
     * Gets if the node is an ElementAccessExpression.
     * @param node - Node to check.
     */
    static isElementAccessExpression(node: Node): node is ElementAccessExpression;
    /**
     * Gets if the node is an EmptyStatement.
     * @param node - Node to check.
     */
    static isEmptyStatement(node: Node): node is EmptyStatement;
    /**
     * Gets if the node is an EnumDeclaration.
     * @param node - Node to check.
     */
    static isEnumDeclaration(node: Node): node is EnumDeclaration;
    /**
     * Gets if the node is an EnumMember.
     * @param node - Node to check.
     */
    static isEnumMember(node: Node): node is EnumMember;
    /**
     * Gets if the node is an ExclamationTokenableNode.
     * @param node - Node to check.
     */
    static isExclamationTokenableNode(node: Node): node is ExclamationTokenableNode & Node;
    /**
     * Gets if the node is an ExportAssignment.
     * @param node - Node to check.
     */
    static isExportAssignment(node: Node): node is ExportAssignment;
    /**
     * Gets if the node is an ExportDeclaration.
     * @param node - Node to check.
     */
    static isExportDeclaration(node: Node): node is ExportDeclaration;
    /**
     * Gets if the node is an ExportSpecifier.
     * @param node - Node to check.
     */
    static isExportSpecifier(node: Node): node is ExportSpecifier;
    /**
     * Gets if the node is an ExportableNode.
     * @param node - Node to check.
     */
    static isExportableNode(node: Node): node is ExportableNode & Node;
    /**
     * Gets if the node is an Expression.
     * @param node - Node to check.
     */
    static isExpression(node: Node): node is Expression;
    /**
     * Gets if the node is an ExpressionStatement.
     * @param node - Node to check.
     */
    static isExpressionStatement(node: Node): node is ExpressionStatement;
    /**
     * Gets if the node is an ExpressionWithTypeArguments.
     * @param node - Node to check.
     */
    static isExpressionWithTypeArguments(node: Node): node is ExpressionWithTypeArguments;
    /**
     * Gets if the node is an ExpressionedNode.
     * @param node - Node to check.
     */
    static isExpressionedNode(node: Node): node is ExpressionedNode & Node;
    /**
     * Gets if the node is an ExtendsClauseableNode.
     * @param node - Node to check.
     */
    static isExtendsClauseableNode(node: Node): node is ExtendsClauseableNode & Node;
    /**
     * Gets if the node is an ExternalModuleReference.
     * @param node - Node to check.
     */
    static isExternalModuleReference(node: Node): node is ExternalModuleReference;
    /**
     * Gets if the node is a FalseKeyword.
     * @param node - Node to check.
     */
    static isFalseKeyword(node: Node): node is BooleanLiteral;
    /**
     * Gets if the node is a ForInStatement.
     * @param node - Node to check.
     */
    static isForInStatement(node: Node): node is ForInStatement;
    /**
     * Gets if the node is a ForOfStatement.
     * @param node - Node to check.
     */
    static isForOfStatement(node: Node): node is ForOfStatement;
    /**
     * Gets if the node is a ForStatement.
     * @param node - Node to check.
     */
    static isForStatement(node: Node): node is ForStatement;
    /**
     * Gets if the node is a FunctionDeclaration.
     * @param node - Node to check.
     */
    static isFunctionDeclaration(node: Node): node is FunctionDeclaration;
    /**
     * Gets if the node is a FunctionExpression.
     * @param node - Node to check.
     */
    static isFunctionExpression(node: Node): node is FunctionExpression;
    /**
     * Gets if the node is a FunctionLikeDeclaration.
     * @param node - Node to check.
     */
    static isFunctionLikeDeclaration(node: Node): node is FunctionLikeDeclaration & Node;
    /**
     * Gets if the node is a FunctionTypeNode.
     * @param node - Node to check.
     */
    static isFunctionTypeNode(node: Node): node is FunctionTypeNode;
    /**
     * Gets if the node is a GeneratorableNode.
     * @param node - Node to check.
     */
    static isGeneratorableNode(node: Node): node is GeneratorableNode & Node;
    /**
     * Gets if the node is a GetAccessorDeclaration.
     * @param node - Node to check.
     */
    static isGetAccessorDeclaration(node: Node): node is GetAccessorDeclaration;
    /**
     * Gets if the node is a HeritageClause.
     * @param node - Node to check.
     */
    static isHeritageClause(node: Node): node is HeritageClause;
    /**
     * Gets if the node is a HeritageClauseableNode.
     * @param node - Node to check.
     */
    static isHeritageClauseableNode(node: Node): node is HeritageClauseableNode & Node;
    /**
     * Gets if the node is a Identifier.
     * @param node - Node to check.
     */
    static isIdentifier(node: Node): node is Identifier;
    /**
     * Gets if the node is a IfStatement.
     * @param node - Node to check.
     */
    static isIfStatement(node: Node): node is IfStatement;
    /**
     * Gets if the node is a ImplementsClauseableNode.
     * @param node - Node to check.
     */
    static isImplementsClauseableNode(node: Node): node is ImplementsClauseableNode & Node;
    /**
     * Gets if the node is a ImportDeclaration.
     * @param node - Node to check.
     */
    static isImportDeclaration(node: Node): node is ImportDeclaration;
    /**
     * Gets if the node is a ImportEqualsDeclaration.
     * @param node - Node to check.
     */
    static isImportEqualsDeclaration(node: Node): node is ImportEqualsDeclaration;
    /**
     * Gets if the node is a ImportExpression.
     * @param node - Node to check.
     */
    static isImportExpression(node: Node): node is ImportExpression;
    /**
     * Gets if the node is a ImportSpecifier.
     * @param node - Node to check.
     */
    static isImportSpecifier(node: Node): node is ImportSpecifier;
    /**
     * Gets if the node is a IndexSignatureDeclaration.
     * @param node - Node to check.
     */
    static isIndexSignatureDeclaration(node: Node): node is IndexSignatureDeclaration;
    /**
     * Gets if the node is a InitializerExpressionableNode.
     * @param node - Node to check.
     */
    static isInitializerExpressionableNode(node: Node): node is InitializerExpressionableNode & Node;
    /**
     * Gets if the node is a InitializerGetExpressionableNode.
     * @param node - Node to check.
     */
    static isInitializerGetExpressionableNode(node: Node): node is InitializerGetExpressionableNode & Node;
    /**
     * Gets if the node is a InitializerSetExpressionableNode.
     * @param node - Node to check.
     */
    static isInitializerSetExpressionableNode(node: Node): node is InitializerSetExpressionableNode & Node;
    /**
     * Gets if the node is a InterfaceDeclaration.
     * @param node - Node to check.
     */
    static isInterfaceDeclaration(node: Node): node is InterfaceDeclaration;
    /**
     * Gets if the node is a IntersectionTypeNode.
     * @param node - Node to check.
     */
    static isIntersectionTypeNode(node: Node): node is IntersectionTypeNode;
    /**
     * Gets if the node is a IterationStatement.
     * @param node - Node to check.
     */
    static isIterationStatement(node: Node): node is IterationStatement;
    /**
     * Gets if the node is a JSDoc.
     * @param node - Node to check.
     */
    static isJSDoc(node: Node): node is JSDoc;
    /**
     * Gets if the node is a JSDocAugmentsTag.
     * @param node - Node to check.
     */
    static isJSDocAugmentsTag(node: Node): node is JSDocAugmentsTag;
    /**
     * Gets if the node is a JSDocClassTag.
     * @param node - Node to check.
     */
    static isJSDocClassTag(node: Node): node is JSDocClassTag;
    /**
     * Gets if the node is a JSDocParameterTag.
     * @param node - Node to check.
     */
    static isJSDocParameterTag(node: Node): node is JSDocParameterTag;
    /**
     * Gets if the node is a JSDocPropertyLikeTag.
     * @param node - Node to check.
     */
    static isJSDocPropertyLikeTag(node: Node): node is JSDocPropertyLikeTag & Node;
    /**
     * Gets if the node is a JSDocPropertyTag.
     * @param node - Node to check.
     */
    static isJSDocPropertyTag(node: Node): node is JSDocPropertyTag;
    /**
     * Gets if the node is a JSDocReturnTag.
     * @param node - Node to check.
     */
    static isJSDocReturnTag(node: Node): node is JSDocReturnTag;
    /**
     * Gets if the node is a JSDocTag.
     * @param node - Node to check.
     */
    static isJSDocTag(node: Node): node is JSDocTag;
    /**
     * Gets if the node is a JSDocTypeTag.
     * @param node - Node to check.
     */
    static isJSDocTypeTag(node: Node): node is JSDocTypeTag;
    /**
     * Gets if the node is a JSDocTypedefTag.
     * @param node - Node to check.
     */
    static isJSDocTypedefTag(node: Node): node is JSDocTypedefTag;
    /**
     * Gets if the node is a JSDocUnknownTag.
     * @param node - Node to check.
     */
    static isJSDocUnknownTag(node: Node): node is JSDocUnknownTag;
    /**
     * Gets if the node is a JSDocableNode.
     * @param node - Node to check.
     */
    static isJSDocableNode(node: Node): node is JSDocableNode & Node;
    /**
     * Gets if the node is a JsxAttribute.
     * @param node - Node to check.
     */
    static isJsxAttribute(node: Node): node is JsxAttribute;
    /**
     * Gets if the node is a JsxAttributedNode.
     * @param node - Node to check.
     */
    static isJsxAttributedNode(node: Node): node is JsxAttributedNode & Node;
    /**
     * Gets if the node is a JsxClosingElement.
     * @param node - Node to check.
     */
    static isJsxClosingElement(node: Node): node is JsxClosingElement;
    /**
     * Gets if the node is a JsxClosingFragment.
     * @param node - Node to check.
     */
    static isJsxClosingFragment(node: Node): node is JsxClosingFragment;
    /**
     * Gets if the node is a JsxElement.
     * @param node - Node to check.
     */
    static isJsxElement(node: Node): node is JsxElement;
    /**
     * Gets if the node is a JsxExpression.
     * @param node - Node to check.
     */
    static isJsxExpression(node: Node): node is JsxExpression;
    /**
     * Gets if the node is a JsxFragment.
     * @param node - Node to check.
     */
    static isJsxFragment(node: Node): node is JsxFragment;
    /**
     * Gets if the node is a JsxOpeningElement.
     * @param node - Node to check.
     */
    static isJsxOpeningElement(node: Node): node is JsxOpeningElement;
    /**
     * Gets if the node is a JsxOpeningFragment.
     * @param node - Node to check.
     */
    static isJsxOpeningFragment(node: Node): node is JsxOpeningFragment;
    /**
     * Gets if the node is a JsxSelfClosingElement.
     * @param node - Node to check.
     */
    static isJsxSelfClosingElement(node: Node): node is JsxSelfClosingElement;
    /**
     * Gets if the node is a JsxSpreadAttribute.
     * @param node - Node to check.
     */
    static isJsxSpreadAttribute(node: Node): node is JsxSpreadAttribute;
    /**
     * Gets if the node is a JsxTagNamedNode.
     * @param node - Node to check.
     */
    static isJsxTagNamedNode(node: Node): node is JsxTagNamedNode & Node;
    /**
     * Gets if the node is a JsxText.
     * @param node - Node to check.
     */
    static isJsxText(node: Node): node is JsxText;
    /**
     * Gets if the node is a LabeledStatement.
     * @param node - Node to check.
     */
    static isLabeledStatement(node: Node): node is LabeledStatement;
    /**
     * Gets if the node is a LeftHandSideExpression.
     * @param node - Node to check.
     */
    static isLeftHandSideExpression(node: Node): node is LeftHandSideExpression;
    /**
     * Gets if the node is a LeftHandSideExpressionedNode.
     * @param node - Node to check.
     */
    static isLeftHandSideExpressionedNode(node: Node): node is LeftHandSideExpressionedNode & Node;
    /**
     * Gets if the node is a LiteralExpression.
     * @param node - Node to check.
     */
    static isLiteralExpression(node: Node): node is LiteralExpression;
    /**
     * Gets if the node is a LiteralLikeNode.
     * @param node - Node to check.
     */
    static isLiteralLikeNode(node: Node): node is LiteralLikeNode & Node;
    /**
     * Gets if the node is a LiteralTypeNode.
     * @param node - Node to check.
     */
    static isLiteralTypeNode(node: Node): node is LiteralTypeNode;
    /**
     * Gets if the node is a MemberExpression.
     * @param node - Node to check.
     */
    static isMemberExpression(node: Node): node is MemberExpression;
    /**
     * Gets if the node is a MetaProperty.
     * @param node - Node to check.
     */
    static isMetaProperty(node: Node): node is MetaProperty;
    /**
     * Gets if the node is a MethodDeclaration.
     * @param node - Node to check.
     */
    static isMethodDeclaration(node: Node): node is MethodDeclaration;
    /**
     * Gets if the node is a MethodSignature.
     * @param node - Node to check.
     */
    static isMethodSignature(node: Node): node is MethodSignature;
    /**
     * Gets if the node is a ModifierableNode.
     * @param node - Node to check.
     */
    static isModifierableNode(node: Node): node is ModifierableNode & Node;
    /**
     * Gets if the node is a NameableNode.
     * @param node - Node to check.
     */
    static isNameableNode(node: Node): node is NameableNode & Node;
    /**
     * Gets if the node is a NamedNode.
     * @param node - Node to check.
     */
    static isNamedNode(node: Node): node is NamedNode & Node;
    /**
     * Gets if the node is a NamespaceChildableNode.
     * @param node - Node to check.
     */
    static isNamespaceChildableNode(node: Node): node is NamespaceChildableNode & Node;
    /**
     * Gets if the node is a NamespaceDeclaration.
     * @param node - Node to check.
     */
    static isNamespaceDeclaration(node: Node): node is NamespaceDeclaration;
    /**
     * Gets if the node is a NeverKeyword.
     * @param node - Node to check.
     */
    static isNeverKeyword(node: Node): node is Expression;
    /**
     * Gets if the node is a NewExpression.
     * @param node - Node to check.
     */
    static isNewExpression(node: Node): node is NewExpression;
    /**
     * Gets if the node is a NoSubstitutionTemplateLiteral.
     * @param node - Node to check.
     */
    static isNoSubstitutionTemplateLiteral(node: Node): node is NoSubstitutionTemplateLiteral;
    /**
     * Gets if the node is a NonNullExpression.
     * @param node - Node to check.
     */
    static isNonNullExpression(node: Node): node is NonNullExpression;
    /**
     * Gets if the node is a NotEmittedStatement.
     * @param node - Node to check.
     */
    static isNotEmittedStatement(node: Node): node is NotEmittedStatement;
    /**
     * Gets if the node is a NullLiteral.
     * @param node - Node to check.
     */
    static isNullLiteral(node: Node): node is NullLiteral;
    /**
     * Gets if the node is a NumberKeyword.
     * @param node - Node to check.
     */
    static isNumberKeyword(node: Node): node is Expression;
    /**
     * Gets if the node is a NumericLiteral.
     * @param node - Node to check.
     */
    static isNumericLiteral(node: Node): node is NumericLiteral;
    /**
     * Gets if the node is a ObjectKeyword.
     * @param node - Node to check.
     */
    static isObjectKeyword(node: Node): node is Expression;
    /**
     * Gets if the node is a ObjectLiteralExpression.
     * @param node - Node to check.
     */
    static isObjectLiteralExpression(node: Node): node is ObjectLiteralExpression;
    /**
     * Gets if the node is a OmittedExpression.
     * @param node - Node to check.
     */
    static isOmittedExpression(node: Node): node is OmittedExpression;
    /**
     * Gets if the node is a OverloadableNode.
     * @param node - Node to check.
     */
    static isOverloadableNode(node: Node): node is OverloadableNode & Node;
    /**
     * Gets if the node is a ParameterDeclaration.
     * @param node - Node to check.
     */
    static isParameterDeclaration(node: Node): node is ParameterDeclaration;
    /**
     * Gets if the node is a ParameteredNode.
     * @param node - Node to check.
     */
    static isParameteredNode(node: Node): node is ParameteredNode & Node;
    /**
     * Gets if the node is a ParenthesizedExpression.
     * @param node - Node to check.
     */
    static isParenthesizedExpression(node: Node): node is ParenthesizedExpression;
    /**
     * Gets if the node is a PartiallyEmittedExpression.
     * @param node - Node to check.
     */
    static isPartiallyEmittedExpression(node: Node): node is PartiallyEmittedExpression;
    /**
     * Gets if the node is a PostfixUnaryExpression.
     * @param node - Node to check.
     */
    static isPostfixUnaryExpression(node: Node): node is PostfixUnaryExpression;
    /**
     * Gets if the node is a PrefixUnaryExpression.
     * @param node - Node to check.
     */
    static isPrefixUnaryExpression(node: Node): node is PrefixUnaryExpression;
    /**
     * Gets if the node is a PrimaryExpression.
     * @param node - Node to check.
     */
    static isPrimaryExpression(node: Node): node is PrimaryExpression;
    /**
     * Gets if the node is a PropertyAccessExpression.
     * @param node - Node to check.
     */
    static isPropertyAccessExpression(node: Node): node is PropertyAccessExpression;
    /**
     * Gets if the node is a PropertyAssignment.
     * @param node - Node to check.
     */
    static isPropertyAssignment(node: Node): node is PropertyAssignment;
    /**
     * Gets if the node is a PropertyDeclaration.
     * @param node - Node to check.
     */
    static isPropertyDeclaration(node: Node): node is PropertyDeclaration;
    /**
     * Gets if the node is a PropertyNamedNode.
     * @param node - Node to check.
     */
    static isPropertyNamedNode(node: Node): node is PropertyNamedNode & Node;
    /**
     * Gets if the node is a PropertySignature.
     * @param node - Node to check.
     */
    static isPropertySignature(node: Node): node is PropertySignature;
    /**
     * Gets if the node is a QualifiedName.
     * @param node - Node to check.
     */
    static isQualifiedName(node: Node): node is QualifiedName;
    /**
     * Gets if the node is a QuestionTokenableNode.
     * @param node - Node to check.
     */
    static isQuestionTokenableNode(node: Node): node is QuestionTokenableNode & Node;
    /**
     * Gets if the node is a ReadonlyableNode.
     * @param node - Node to check.
     */
    static isReadonlyableNode(node: Node): node is ReadonlyableNode & Node;
    /**
     * Gets if the node is a ReferenceFindableNode.
     * @param node - Node to check.
     */
    static isReferenceFindableNode(node: Node): node is ReferenceFindableNode & Node;
    /**
     * Gets if the node is a RegularExpressionLiteral.
     * @param node - Node to check.
     */
    static isRegularExpressionLiteral(node: Node): node is RegularExpressionLiteral;
    /**
     * Gets if the node is a ReturnStatement.
     * @param node - Node to check.
     */
    static isReturnStatement(node: Node): node is ReturnStatement;
    /**
     * Gets if the node is a ReturnTypedNode.
     * @param node - Node to check.
     */
    static isReturnTypedNode(node: Node): node is ReturnTypedNode & Node;
    /**
     * Gets if the node is a ScopeableNode.
     * @param node - Node to check.
     */
    static isScopeableNode(node: Node): node is ScopeableNode & Node;
    /**
     * Gets if the node is a ScopedNode.
     * @param node - Node to check.
     */
    static isScopedNode(node: Node): node is ScopedNode & Node;
    /**
     * Gets if the node is a SemicolonToken.
     * @param node - Node to check.
     */
    static isSemicolonToken(node: Node): node is Node;
    /**
     * Gets if the node is a SetAccessorDeclaration.
     * @param node - Node to check.
     */
    static isSetAccessorDeclaration(node: Node): node is SetAccessorDeclaration;
    /**
     * Gets if the node is a ShorthandPropertyAssignment.
     * @param node - Node to check.
     */
    static isShorthandPropertyAssignment(node: Node): node is ShorthandPropertyAssignment;
    /**
     * Gets if the node is a SignaturedDeclaration.
     * @param node - Node to check.
     */
    static isSignaturedDeclaration(node: Node): node is SignaturedDeclaration & Node;
    /**
     * Gets if the node is a SourceFile.
     * @param node - Node to check.
     */
    static isSourceFile(node: Node): node is SourceFile;
    /**
     * Gets if the node is a SpreadAssignment.
     * @param node - Node to check.
     */
    static isSpreadAssignment(node: Node): node is SpreadAssignment;
    /**
     * Gets if the node is a SpreadElement.
     * @param node - Node to check.
     */
    static isSpreadElement(node: Node): node is SpreadElement;
    /**
     * Gets if the node is a Statement.
     * @param node - Node to check.
     */
    static isStatement(node: Node): node is Statement;
    /**
     * Gets if the node is a StatementedNode.
     * @param node - Node to check.
     */
    static isStatementedNode(node: Node): node is StatementedNode & Node;
    /**
     * Gets if the node is a StaticableNode.
     * @param node - Node to check.
     */
    static isStaticableNode(node: Node): node is StaticableNode & Node;
    /**
     * Gets if the node is a StringKeyword.
     * @param node - Node to check.
     */
    static isStringKeyword(node: Node): node is Expression;
    /**
     * Gets if the node is a StringLiteral.
     * @param node - Node to check.
     */
    static isStringLiteral(node: Node): node is StringLiteral;
    /**
     * Gets if the node is a SuperExpression.
     * @param node - Node to check.
     */
    static isSuperExpression(node: Node): node is SuperExpression;
    /**
     * Gets if the node is a SwitchStatement.
     * @param node - Node to check.
     */
    static isSwitchStatement(node: Node): node is SwitchStatement;
    /**
     * Gets if the node is a SymbolKeyword.
     * @param node - Node to check.
     */
    static isSymbolKeyword(node: Node): node is Expression;
    /**
     * Gets if the node is a SyntaxList.
     * @param node - Node to check.
     */
    static isSyntaxList(node: Node): node is SyntaxList;
    /**
     * Gets if the node is a TaggedTemplateExpression.
     * @param node - Node to check.
     */
    static isTaggedTemplateExpression(node: Node): node is TaggedTemplateExpression;
    /**
     * Gets if the node is a TemplateExpression.
     * @param node - Node to check.
     */
    static isTemplateExpression(node: Node): node is TemplateExpression;
    /**
     * Gets if the node is a TemplateHead.
     * @param node - Node to check.
     */
    static isTemplateHead(node: Node): node is TemplateHead;
    /**
     * Gets if the node is a TemplateMiddle.
     * @param node - Node to check.
     */
    static isTemplateMiddle(node: Node): node is TemplateMiddle;
    /**
     * Gets if the node is a TemplateSpan.
     * @param node - Node to check.
     */
    static isTemplateSpan(node: Node): node is TemplateSpan;
    /**
     * Gets if the node is a TemplateTail.
     * @param node - Node to check.
     */
    static isTemplateTail(node: Node): node is TemplateTail;
    /**
     * Gets if the node is a TextInsertableNode.
     * @param node - Node to check.
     */
    static isTextInsertableNode(node: Node): node is TextInsertableNode & Node;
    /**
     * Gets if the node is a ThisExpression.
     * @param node - Node to check.
     */
    static isThisExpression(node: Node): node is ThisExpression;
    /**
     * Gets if the node is a ThrowStatement.
     * @param node - Node to check.
     */
    static isThrowStatement(node: Node): node is ThrowStatement;
    /**
     * Gets if the node is a TrueKeyword.
     * @param node - Node to check.
     */
    static isTrueKeyword(node: Node): node is BooleanLiteral;
    /**
     * Gets if the node is a TryStatement.
     * @param node - Node to check.
     */
    static isTryStatement(node: Node): node is TryStatement;
    /**
     * Gets if the node is a TupleTypeNode.
     * @param node - Node to check.
     */
    static isTupleTypeNode(node: Node): node is TupleTypeNode;
    /**
     * Gets if the node is a TypeAliasDeclaration.
     * @param node - Node to check.
     */
    static isTypeAliasDeclaration(node: Node): node is TypeAliasDeclaration;
    /**
     * Gets if the node is a TypeArgumentedNode.
     * @param node - Node to check.
     */
    static isTypeArgumentedNode(node: Node): node is TypeArgumentedNode & Node;
    /**
     * Gets if the node is a TypeAssertion.
     * @param node - Node to check.
     */
    static isTypeAssertion(node: Node): node is TypeAssertion;
    /**
     * Gets if the node is a TypeElement.
     * @param node - Node to check.
     */
    static isTypeElement(node: Node): node is TypeElement;
    /**
     * Gets if the node is a TypeElementMemberedNode.
     * @param node - Node to check.
     */
    static isTypeElementMemberedNode(node: Node): node is TypeElementMemberedNode & Node;
    /**
     * Gets if the node is a TypeLiteralNode.
     * @param node - Node to check.
     */
    static isTypeLiteralNode(node: Node): node is TypeLiteralNode;
    /**
     * Gets if the node is a TypeNode.
     * @param node - Node to check.
     */
    static isTypeNode(node: Node): node is TypeNode;
    /**
     * Gets if the node is a TypeOfExpression.
     * @param node - Node to check.
     */
    static isTypeOfExpression(node: Node): node is TypeOfExpression;
    /**
     * Gets if the node is a TypeParameterDeclaration.
     * @param node - Node to check.
     */
    static isTypeParameterDeclaration(node: Node): node is TypeParameterDeclaration;
    /**
     * Gets if the node is a TypeParameteredNode.
     * @param node - Node to check.
     */
    static isTypeParameteredNode(node: Node): node is TypeParameteredNode & Node;
    /**
     * Gets if the node is a TypeReferenceNode.
     * @param node - Node to check.
     */
    static isTypeReferenceNode(node: Node): node is TypeReferenceNode;
    /**
     * Gets if the node is a TypedNode.
     * @param node - Node to check.
     */
    static isTypedNode(node: Node): node is TypedNode & Node;
    /**
     * Gets if the node is a UnaryExpression.
     * @param node - Node to check.
     */
    static isUnaryExpression(node: Node): node is UnaryExpression;
    /**
     * Gets if the node is a UnaryExpressionedNode.
     * @param node - Node to check.
     */
    static isUnaryExpressionedNode(node: Node): node is UnaryExpressionedNode & Node;
    /**
     * Gets if the node is a UndefinedKeyword.
     * @param node - Node to check.
     */
    static isUndefinedKeyword(node: Node): node is Expression;
    /**
     * Gets if the node is a UnionTypeNode.
     * @param node - Node to check.
     */
    static isUnionTypeNode(node: Node): node is UnionTypeNode;
    /**
     * Gets if the node is a UnwrappableNode.
     * @param node - Node to check.
     */
    static isUnwrappableNode(node: Node): node is UnwrappableNode & Node;
    /**
     * Gets if the node is a UpdateExpression.
     * @param node - Node to check.
     */
    static isUpdateExpression(node: Node): node is UpdateExpression;
    /**
     * Gets if the node is a VariableDeclaration.
     * @param node - Node to check.
     */
    static isVariableDeclaration(node: Node): node is VariableDeclaration;
    /**
     * Gets if the node is a VariableDeclarationList.
     * @param node - Node to check.
     */
    static isVariableDeclarationList(node: Node): node is VariableDeclarationList;
    /**
     * Gets if the node is a VariableStatement.
     * @param node - Node to check.
     */
    static isVariableStatement(node: Node): node is VariableStatement;
    /**
     * Gets if the node is a VoidExpression.
     * @param node - Node to check.
     */
    static isVoidExpression(node: Node): node is VoidExpression;
    /**
     * Gets if the node is a WhileStatement.
     * @param node - Node to check.
     */
    static isWhileStatement(node: Node): node is WhileStatement;
    /**
     * Gets if the node is a WithStatement.
     * @param node - Node to check.
     */
    static isWithStatement(node: Node): node is WithStatement;
    /**
     * Gets if the node is a YieldExpression.
     * @param node - Node to check.
     */
    static isYieldExpression(node: Node): node is YieldExpression;
}

export declare type SourceFileReferencingNodes = ImportDeclaration | ExportDeclaration | ImportEqualsDeclaration | CallExpression;

export declare type PropertyName = Identifier | StringLiteral | NumericLiteral | ComputedPropertyName;

export declare type AccessorDeclaration = GetAccessorDeclaration | SetAccessorDeclaration;

export declare type EntityName = Identifier | QualifiedName;

export declare type JsxChild = JsxText | JsxExpression | JsxElement | JsxSelfClosingElement | JsxFragment;

export declare type JsxAttributeLike = JsxAttribute | JsxSpreadAttribute;

export declare type JsxTagNameExpression = PrimaryExpression | PropertyAccessExpression;

export declare type ObjectLiteralElementLike = PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment | MethodDeclaration | AccessorDeclaration;

export declare type CaseOrDefaultClause = CaseClause | DefaultClause;

export declare type ModuleReference = EntityName | ExternalModuleReference;

export declare type TypeElementTypes = PropertySignature | MethodSignature | ConstructSignatureDeclaration | CallSignatureDeclaration | IndexSignatureDeclaration;

export declare type TemplateLiteral = TemplateExpression | NoSubstitutionTemplateLiteral;

export declare type AmbientableNodeExtensionType = Node & ModifierableNode;

export interface AmbientableNode {
    /**
     * If the node has the declare keyword.
     */
    hasDeclareKeyword(): boolean;
    /**
     * Gets the declare keyword or undefined if none exists.
     */
    getDeclareKeyword(): Node | undefined;
    /**
     * Gets the declare keyword or throws if it doesn't exist.
     */
    getDeclareKeywordOrThrow(): Node;
    /**
     * Gets if the node is ambient.
     */
    isAmbient(): boolean;
    /**
     * Sets if this node has a declare keyword.
     * @param value - To add the declare keyword or not.
     */
    setHasDeclareKeyword(value?: boolean): this;
}

export declare function AmbientableNode<T extends Constructor<AmbientableNodeExtensionType>>(Base: T): Constructor<AmbientableNode> & T;

export declare type ArgumentedNodeExtensionType = Node<ts.Node & {
    arguments: ts.NodeArray<ts.Node>;
}>;

export interface ArgumentedNode {
    /**
     * Gets all the arguments of the node.
     */
    getArguments(): Node[];
    /**
     * Adds an argument.
     * @param argumentText - Argument text to add.
     */
    addArgument(argumentText: string | WriterFunction): Node;
    /**
     * Adds arguments.
     * @param argumentTexts - Argument texts to add.
     */
    addArguments(argumentTexts: (string | WriterFunction)[]): Node[];
    /**
     * Inserts an argument.
     * @param index - Index to insert at.
     * @param argumentText - Argument text to insert.
     */
    insertArgument(index: number, argumentText: string | WriterFunction): Node;
    /**
     * Inserts arguments.
     * @param index - Index to insert at.
     * @param argumentTexts - Argument texts to insert.
     */
    insertArguments(index: number, argumentTexts: (string | WriterFunction)[]): Node[];
    /**
     * Removes an argument.
     * @param arg - Argument to remove.
     */
    removeArgument(arg: Node): this;
    /**
     * Removes an argument.
     * @param index - Index to remove.
     */
    removeArgument(index: number): this;
}

export declare function ArgumentedNode<T extends Constructor<ArgumentedNodeExtensionType>>(Base: T): Constructor<ArgumentedNode> & T;

export declare type AsyncableNodeExtensionType = Node & ModifierableNode;

export interface AsyncableNode {
    /**
     * If it's async.
     */
    isAsync(): boolean;
    /**
     * Gets the async keyword or undefined if none exists.
     */
    getAsyncKeyword(): Node<ts.Modifier> | undefined;
    /**
     * Gets the async keyword or throws if none exists.
     */
    getAsyncKeywordOrThrow(): Node<ts.Modifier>;
    /**
     * Sets if the node is async.
     * @param value - If it should be async or not.
     */
    setIsAsync(value: boolean): this;
}

export declare function AsyncableNode<T extends Constructor<AsyncableNodeExtensionType>>(Base: T): Constructor<AsyncableNode> & T;

export declare type AwaitableNodeExtensionType = Node<ts.Node & {
    awaitModifier?: ts.AwaitKeywordToken;
}>;

export interface AwaitableNode {
    /**
     * If it's an awaited node.
     */
    isAwaited(): boolean;
    /**
     * Gets the await token or undefined if none exists.
     */
    getAwaitKeyword(): Node<ts.AwaitKeywordToken> | undefined;
    /**
     * Gets the await token or throws if none exists.
     */
    getAwaitKeywordOrThrow(): Node<ts.AwaitKeywordToken>;
    /**
     * Sets if the node is awaited.
     * @param value - If it should be awaited or not.
     */
    setIsAwaited(value: boolean): this;
}

export declare function AwaitableNode<T extends Constructor<AwaitableNodeExtensionType>>(Base: T): Constructor<AwaitableNode> & T;

export declare type BodiedNodeExtensionType = Node<ts.Node & {
    body: ts.Node;
}>;

export interface BodiedNode {
    /**
     * Gets the body.
     */
    getBody(): Node;
    /**
     * Sets the body text.
     * @param writerFunction - Write the text using the provided writer.
     */
    setBodyText(writerFunction: WriterFunction): this;
    /**
     * Sets the body text.
     * @param text - Text to set as the body.
     */
    setBodyText(text: string): this;
}

export declare function BodiedNode<T extends Constructor<BodiedNodeExtensionType>>(Base: T): Constructor<BodiedNode> & T;

export declare type BodyableNodeExtensionType = Node<ts.Node & {
    body?: ts.Node;
}>;

export interface BodyableNode {
    /**
     * Gets the body or throws an error if it doesn't exist.
     */
    getBodyOrThrow(): Node;
    /**
     * Gets the body if it exists.
     */
    getBody(): Node | undefined;
    /**
     * Gets if the node has a body.
     */
    hasBody(): boolean;
    /**
     * Sets the body text. A body is required to do this operation.
     * @param writerFunction - Write the text using the provided writer.
     */
    setBodyText(writerFunction: WriterFunction): this;
    /**
     * Sets the body text. A body is required to do this operation.
     * @param text - Text to set as the body.
     */
    setBodyText(text: string): this;
    /**
     * Adds a body if it doesn't exists.
     */
    addBody(): this;
    /**
     * Removes the body if it exists.
     */
    removeBody(): this;
}

export declare function BodyableNode<T extends Constructor<BodyableNodeExtensionType>>(Base: T): Constructor<BodyableNode> & T;

export interface ChildOrderableNode {
    /**
     * Sets the child order of the node within the parent.
     */
    setOrder(order: number): this;
}

export declare function ChildOrderableNode<T extends Constructor<Node>>(Base: T): Constructor<ChildOrderableNode> & T;

export declare type DecoratableNodeExtensionType = Node<ts.Node & {
    decorators: ts.NodeArray<ts.Decorator> | undefined;
}>;

export interface DecoratableNode {
    /**
     * Gets a decorator or undefined if it doesn't exist.
     * @param name - Name of the parameter.
     */
    getDecorator(name: string): Decorator | undefined;
    /**
     * Gets a decorator or undefined if it doesn't exist.
     * @param findFunction - Function to use to find the parameter.
     */
    getDecorator(findFunction: (declaration: Decorator) => boolean): Decorator | undefined;
    /**
     * Gets a decorator or throws if it doesn't exist.
     * @param name - Name of the parameter.
     */
    getDecoratorOrThrow(name: string): Decorator;
    /**
     * Gets a decorator or throws if it doesn't exist.
     * @param findFunction - Function to use to find the parameter.
     */
    getDecoratorOrThrow(findFunction: (declaration: Decorator) => boolean): Decorator;
    /**
     * Gets all the decorators of the node.
     */
    getDecorators(): Decorator[];
    /**
     * Adds a decorator.
     * @param structure - Structure of the decorator.
     */
    addDecorator(structure: DecoratorStructure): Decorator;
    /**
     * Adds decorators.
     * @param structures - Structures of the decorators.
     */
    addDecorators(structures: DecoratorStructure[]): Decorator[];
    /**
     * Inserts a decorator.
     * @param index - Index to insert at. Specify a negative index to insert from the reverse.
     * @param structure - Structure of the decorator.
     */
    insertDecorator(index: number, structure: DecoratorStructure): Decorator;
    /**
     * Insert decorators.
     * @param index - Index to insert at.
     * @param structures - Structures to insert.
     */
    insertDecorators(index: number, structures: DecoratorStructure[]): Decorator[];
}

export declare function DecoratableNode<T extends Constructor<DecoratableNodeExtensionType>>(Base: T): Constructor<DecoratableNode> & T;

export declare type ExclamationTokenableNodeExtensionType = Node<ts.Node & {
    exclamationToken?: ts.ExclamationToken;
}>;

export interface ExclamationTokenableNode {
    /**
     * If it has a exclamation token.
     */
    hasExclamationToken(): boolean;
    /**
     * Gets the exclamation token node or returns undefined if it doesn't exist.
     */
    getExclamationTokenNode(): Node<ts.ExclamationToken> | undefined;
    /**
     * Gets the exclamation token node or throws.
     */
    getExclamationTokenNodeOrThrow(): Node<ts.ExclamationToken>;
    /**
     * Sets if this node has a exclamation token.
     * @param value - If it should have a exclamation token or not.
     */
    setHasExclamationToken(value: boolean): this;
}

export declare function ExclamationTokenableNode<T extends Constructor<ExclamationTokenableNodeExtensionType>>(Base: T): Constructor<ExclamationTokenableNode> & T;

export declare type ExportableNodeExtensionType = Node & ModifierableNode;

export interface ExportableNode {
    /**
     * If the node has the export keyword.
     */
    hasExportKeyword(): boolean;
    /**
     * Gets the export keyword or undefined if none exists.
     */
    getExportKeyword(): Node | undefined;
    /**
     * Gets the export keyword or throws if none exists.
     */
    getExportKeywordOrThrow(): Node;
    /**
     * If the node has the default keyword.
     */
    hasDefaultKeyword(): boolean;
    /**
     * Gets the default keyword or undefined if none exists.
     */
    getDefaultKeyword(): Node | undefined;
    /**
     * Gets the default keyword or throws if none exists.
     */
    getDefaultKeywordOrThrow(): Node;
    /**
     * Gets if the node is exported from a namespace, is a default export, or is a named export.
     */
    isExported(): boolean;
    /**
     * Gets if this node is a default export of a file.
     */
    isDefaultExport(): boolean;
    /**
     * Gets if this node is a named export of a file.
     */
    isNamedExport(): boolean;
    /**
     * Sets if this node is a default export of a file.
     * @param value - If it should be a default export or not.
     */
    setIsDefaultExport(value: boolean): this;
    /**
     * Sets if the node is exported.
     *
     * Note: Will remove the default keyword if set.
     * @param value - If it should be exported or not.
     */
    setIsExported(value: boolean): this;
}

export declare function ExportableNode<T extends Constructor<ExportableNodeExtensionType>>(Base: T): Constructor<ExportableNode> & T;

export declare type ExtendsClauseableNodeExtensionType = Node & HeritageClauseableNode;

export interface ExtendsClauseableNode {
    /**
     * Gets the extends clauses.
     */
    getExtends(): ExpressionWithTypeArguments[];
    /**
     * Adds multiple extends clauses.
     * @param texts - Texts to add for the extends clause.
     */
    addExtends(texts: string[]): ExpressionWithTypeArguments[];
    /**
     * Adds an extends clause.
     * @param text - Text to add for the extends clause.
     */
    addExtends(text: string): ExpressionWithTypeArguments;
    /**
     * Inserts multiple extends clauses.
     * @param texts - Texts to insert for the extends clause.
     */
    insertExtends(index: number, texts: string[]): ExpressionWithTypeArguments[];
    /**
     * Inserts an extends clause.
     * @param text - Text to insert for the extends clause.
     */
    insertExtends(index: number, text: string): ExpressionWithTypeArguments;
    /**
     * Removes the extends at the specified index.
     * @param index - Index to remove.
     */
    removeExtends(index: number): this;
    /**
     * Removes the specified extends.
     * @param extendsNode - Node of the extend to remove.
     */
    removeExtends(extendsNode: ExpressionWithTypeArguments): this;
}

export declare function ExtendsClauseableNode<T extends Constructor<ExtendsClauseableNodeExtensionType>>(Base: T): Constructor<ExtendsClauseableNode> & T;

export declare type GeneratorableNodeExtensionType = Node<ts.Node & {
    asteriskToken?: ts.AsteriskToken;
}>;

export interface GeneratorableNode {
    /**
     * If it's a generator function.
     */
    isGenerator(): boolean;
    /**
     * Gets the asterisk token or undefined if none exists.
     */
    getAsteriskToken(): Node<ts.AsteriskToken> | undefined;
    /**
     * Gets the asterisk token or throws if none exists.
     */
    getAsteriskTokenOrThrow(): Node<ts.AsteriskToken>;
    /**
     * Sets if the node is a generator.
     * @param value - If it should be a generator or not.
     */
    setIsGenerator(value: boolean): this;
}

export declare function GeneratorableNode<T extends Constructor<GeneratorableNodeExtensionType>>(Base: T): Constructor<GeneratorableNode> & T;

export declare type HeritageClauseableNodeExtensionType = Node<ts.Node & {
    heritageClauses?: ts.NodeArray<ts.HeritageClause>;
}>;

export interface HeritageClauseableNode {
    /**
     * Gets the heritage clauses of the node.
     */
    getHeritageClauses(): HeritageClause[];
    /**
     * Gets the heritage clause by kind.
     * @kind - Kind of heritage clause.
     */
    getHeritageClauseByKind(kind: SyntaxKind.ExtendsKeyword | SyntaxKind.ImplementsKeyword): HeritageClause | undefined;
    /**
     * Gets the heritage clause by kind or throws if it doesn't exist.
     * @kind - Kind of heritage clause.
     */
    getHeritageClauseByKindOrThrow(kind: SyntaxKind.ExtendsKeyword | SyntaxKind.ImplementsKeyword): HeritageClause;
}

export declare function HeritageClauseableNode<T extends Constructor<HeritageClauseableNodeExtensionType>>(Base: T): Constructor<HeritageClauseableNode> & T;

export declare type ImplementsClauseableNodeExtensionType = Node & HeritageClauseableNode;

export interface ImplementsClauseableNode {
    /**
     * Gets the implements clauses.
     */
    getImplements(): ExpressionWithTypeArguments[];
    /**
     * Adds an implements clause.
     * @param text - Text to add for the implements clause.
     */
    addImplements(text: string): ExpressionWithTypeArguments;
    /**
     * Adds multiple implements clauses.
     * @param text - Texts to add for the implements clause.
     */
    addImplements(text: string[]): ExpressionWithTypeArguments[];
    /**
     * Inserts an implements clause.
     * @param text - Text to insert for the implements clause.
     */
    insertImplements(index: number, texts: string[]): ExpressionWithTypeArguments[];
    /**
     * Inserts multiple implements clauses.
     * @param text - Texts to insert for the implements clause.
     */
    insertImplements(index: number, text: string): ExpressionWithTypeArguments;
    /**
     * Removes the implements at the specified index.
     * @param index - Index to remove.
     */
    removeImplements(index: number): this;
    /**
     * Removes the specified implements.
     * @param implementsNode - Node of the implements to remove.
     */
    removeImplements(implementsNode: ExpressionWithTypeArguments): this;
}

export declare function ImplementsClauseableNode<T extends Constructor<ImplementsClauseableNodeExtensionType>>(Base: T): Constructor<ImplementsClauseableNode> & T;

export declare type JSDocableNodeExtensionType = Node<ts.Node & {
    jsDoc?: ts.NodeArray<ts.JSDoc>;
}>;

export interface JSDocableNode {
    /**
     * Gets the JS doc nodes.
     */
    getJsDocs(): JSDoc[];
    /**
     * Adds a JS doc.
     * @param structure - Structure to add.
     */
    addJsDoc(structure: JSDocStructure | string): JSDoc;
    /**
     * Adds JS docs.
     * @param structures - Structures to add.
     */
    addJsDocs(structures: (JSDocStructure | string)[]): JSDoc[];
    /**
     * Inserts a JS doc.
     * @param index - Index to insert at.
     * @param structure - Structure to insert.
     */
    insertJsDoc(index: number, structure: JSDocStructure | string): JSDoc;
    /**
     * Inserts JS docs.
     * @param index - Index to insert at.
     * @param structures - Structures to insert.
     */
    insertJsDocs(index: number, structures: (JSDocStructure | string)[]): JSDoc[];
}

export declare function JSDocableNode<T extends Constructor<JSDocableNodeExtensionType>>(Base: T): Constructor<JSDocableNode> & T;

export declare type LiteralLikeNodeExtensionType = Node<ts.LiteralLikeNode>;

export interface LiteralLikeNode {
    /**
     * Get text of the literal.
     */
    getLiteralText(): string;
    /**
     * Gets if the literal is terminated.
     */
    isTerminated(): boolean;
    /**
     * Gets if the literal has an extended unicode escape.
     */
    hasExtendedUnicodeEscape(): boolean;
}

export declare function LiteralLikeNode<T extends Constructor<LiteralLikeNodeExtensionType>>(Base: T): Constructor<LiteralLikeNode> & T;

export declare type ModiferableNodeExtensionType = Node;

export declare type ModifierTexts = "export" | "default" | "declare" | "abstract" | "public" | "protected" | "private" | "readonly" | "static" | "async" | "const";

export interface ModifierableNode {
    /**
     * Gets the node's modifiers.
     */
    getModifiers(): Node[];
    /**
     * Gets the first modifier of the specified syntax kind or throws if none found.
     * @param kind - Syntax kind.
     */
    getFirstModifierByKindOrThrow<TKind extends SyntaxKind>(kind: TKind): KindToNodeMappings[TKind];
    /**
     * Gets the first modifier of the specified syntax kind or undefined if none found.
     * @param kind - Syntax kind.
     */
    getFirstModifierByKind<TKind extends SyntaxKind>(kind: TKind): KindToNodeMappings[TKind] | undefined;
    /**
     * Gets if it has the specified modifier.
     * @param kind - Syntax kind to check for.
     */
    hasModifier(kind: SyntaxKind): boolean;
    /**
     * Gets if it has the specified modifier.
     * @param text - Text to check for.
     */
    hasModifier(text: ModifierTexts): boolean;
    /**
     * Toggles a modifier.
     * @param text - Text to toggle the modifier for.
     * @param value - Optional toggling value.
     */
    toggleModifier(text: ModifierTexts, value?: boolean): this;
}

export declare function ModifierableNode<T extends Constructor<ModiferableNodeExtensionType>>(Base: T): Constructor<ModifierableNode> & T;

export declare type ParameteredNodeExtensionType = Node<ts.Node & {
    parameters: ts.NodeArray<ts.ParameterDeclaration>;
}>;

export interface ParameteredNode {
    /**
     * Gets a parameter or undefined if it doesn't exist.
     * @param name - Name of the parameter.
     */
    getParameter(name: string): ParameterDeclaration | undefined;
    /**
     * Gets a parameter or undefined if it doesn't exist.
     * @param findFunction - Function to use to find the parameter.
     */
    getParameter(findFunction: (declaration: ParameterDeclaration) => boolean): ParameterDeclaration | undefined;
    /**
     * Gets a parameter or throws if it doesn't exist.
     * @param name - Name of the parameter.
     */
    getParameterOrThrow(name: string): ParameterDeclaration;
    /**
     * Gets a parameter or throws if it doesn't exist.
     * @param findFunction - Function to use to find the parameter.
     */
    getParameterOrThrow(findFunction: (declaration: ParameterDeclaration) => boolean): ParameterDeclaration;
    /**
     * Gets all the parameters of the node.
     */
    getParameters(): ParameterDeclaration[];
    /**
     * Adds a parameter.
     * @param structure - Structure of the parameter.
     */
    addParameter(structure: ParameterDeclarationStructure): ParameterDeclaration;
    /**
     * Adds parameters.
     * @param structures - Structures of the parameters.
     */
    addParameters(structures: ParameterDeclarationStructure[]): ParameterDeclaration[];
    /**
     * Inserts parameters.
     * @param index - Index to insert at.
     * @param structures - Parameters to insert.
     */
    insertParameters(index: number, structures: ParameterDeclarationStructure[]): ParameterDeclaration[];
    /**
     * Inserts a parameter.
     * @param index - Index to insert at.
     * @param structures - Parameter to insert.
     */
    insertParameter(index: number, structure: ParameterDeclarationStructure): ParameterDeclaration;
}

export declare function ParameteredNode<T extends Constructor<ParameteredNodeExtensionType>>(Base: T): Constructor<ParameteredNode> & T;

export declare type QuestionTokenableNodeExtensionType = Node<ts.Node & {
    questionToken?: ts.QuestionToken;
}>;

export interface QuestionTokenableNode {
    /**
     * If it has a question token.
     */
    hasQuestionToken(): boolean;
    /**
     * Gets the question token node or returns undefined if it doesn't exist.
     */
    getQuestionTokenNode(): Node<ts.QuestionToken> | undefined;
    /**
     * Gets the question token node or throws.
     */
    getQuestionTokenNodeOrThrow(): Node<ts.QuestionToken>;
    /**
     * Sets if this node has a question token.
     * @param value - If it should have a question token or not.
     */
    setHasQuestionToken(value: boolean): this;
}

export declare function QuestionTokenableNode<T extends Constructor<QuestionTokenableNodeExtensionType>>(Base: T): Constructor<QuestionTokenableNode> & T;

export declare type ReadonlyableNodeExtensionType = Node & ModifierableNode;

export interface ReadonlyableNode {
    /**
     * Gets if it's readonly.
     */
    isReadonly(): boolean;
    /**
     * Gets the readonly keyword, or undefined if none exists.
     */
    getReadonlyKeyword(): Node | undefined;
    /**
     * Gets the readonly keyword, or throws if none exists.
     */
    getReadonlyKeywordOrThrow(): Node;
    /**
     * Sets if this node is readonly.
     * @param value - If readonly or not.
     */
    setIsReadonly(value: boolean): this;
}

export declare function ReadonlyableNode<T extends Constructor<ReadonlyableNodeExtensionType>>(Base: T): Constructor<ReadonlyableNode> & T;

export declare type ReturnTypedNodeExtensionReturnType = Node<ts.SignatureDeclaration>;

export interface ReturnTypedNode {
    /**
     * Gets the return type.
     */
    getReturnType(): Type;
    /**
     * Gets the return type node or undefined if none exists.
     */
    getReturnTypeNode(): TypeNode | undefined;
    /**
     * Gets the return type node or throws if none exists.
     */
    getReturnTypeNodeOrThrow(): TypeNode;
    /**
     * Sets the return type of the node.
     * @param writerFunction - Writer function to set the return type with.
     */
    setReturnType(writerFunction: WriterFunction): this;
    /**
     * Sets the return type of the node.
     * @param text - Text to set as the type.
     */
    setReturnType(text: string): this;
    /**
     * Removes the return type.
     */
    removeReturnType(): this;
}

export declare function ReturnTypedNode<T extends Constructor<ReturnTypedNodeExtensionReturnType>>(Base: T): Constructor<ReturnTypedNode> & T;

export declare type ScopeableNodeExtensionType = Node & ModifierableNode;

export interface ScopeableNode {
    /**
     * Gets the scope.
     */
    getScope(): Scope | undefined;
    /**
     * Sets the scope.
     * @param scope - Scope to set to.
     */
    setScope(scope: Scope | undefined): this;
    /**
     * Gets if the node has a scope keyword.
     */
    hasScopeKeyword(): boolean;
}

export declare function ScopeableNode<T extends Constructor<ScopeableNodeExtensionType>>(Base: T): Constructor<ScopeableNode> & T;

export declare type ScopedNodeExtensionType = Node & ModifierableNode;

export interface ScopedNode {
    /**
     * Gets the scope.
     */
    getScope(): Scope;
    /**
     * Sets the scope.
     * @param scope - Scope to set to.
     */
    setScope(scope: Scope | undefined): this;
    /**
     * Gets if the node has a scope keyword.
     */
    hasScopeKeyword(): boolean;
}

export declare function ScopedNode<T extends Constructor<ScopedNodeExtensionType>>(Base: T): Constructor<ScopedNode> & T;

export declare type SignaturedDeclarationExtensionType = Node<ts.SignatureDeclaration>;

export interface SignaturedDeclaration extends ParameteredNode, ReturnTypedNode {
}

export declare function SignaturedDeclaration<T extends Constructor<SignaturedDeclarationExtensionType>>(Base: T): Constructor<SignaturedDeclaration> & T;

export declare type StaticableNodeExtensionType = Node & ModifierableNode;

export interface StaticableNode {
    /**
     * Gets if it's static.
     */
    isStatic(): boolean;
    /**
     * Gets the static keyword, or undefined if none exists.
     */
    getStaticKeyword(): Node | undefined;
    /**
     * Gets the static keyword, or throws if none exists.
     */
    getStaticKeywordOrThrow(): Node;
    /**
     * Sets if the node is static.
     * @param value - If it should be static or not.
     */
    setIsStatic(value: boolean): this;
}

export declare function StaticableNode<T extends Constructor<StaticableNodeExtensionType>>(Base: T): Constructor<StaticableNode> & T;

export declare type TextInsertableNodeExtensionType = Node;

export interface TextInsertableNode {
    /**
     * Inserts text within the body of the node.
     *
     * WARNING: This will forget any previously navigated descendant nodes.
     * @param pos - Position to insert at.
     * @param text - Text to insert.
     */
    insertText(pos: number, text: string): this;
    /**
     * Inserts text within the body of the node using a writer.
     *
     * WARNING: This will forget any previously navigated descendant nodes.
     * @param pos - Position to insert at.
     * @param writerFunction - Write the text using the provided writer.
     */
    insertText(pos: number, writerFunction: WriterFunction): this;
    /**
     * Replaces text within the body of the node.
     *
     * WARNING: This will forget any previously navigated descendant nodes.
     * @param range - Start and end position of the text to replace.
     * @param text - Text to replace the range with.
     */
    replaceText(range: [number, number], text: string): this;
    /**
     * Replaces text within the body of the node using a writer function.
     *
     * WARNING: This will forget any previously navigated descendant nodes.
     * @param range - Start and end position of the text to replace.
     * @param writerFunction - Write the text using the provided writer.
     */
    replaceText(range: [number, number], writerFunction: WriterFunction): this;
    /**
     * Removes all the text within the node
     */
    removeText(): this;
    /**
     * Removes text within the body of the node.
     *
     * WARNING: This will forget any previously navigated descendant nodes.
     * @param pos - Start position to remove.
     * @param end - End position to remove.
     */
    removeText(pos: number, end: number): this;
}

export declare function TextInsertableNode<T extends Constructor<TextInsertableNodeExtensionType>>(Base: T): Constructor<TextInsertableNode> & T;

export declare type TypeArgumentedNodeExtensionType = Node<ts.Node & {
    typeArguments?: ts.NodeArray<ts.TypeNode>;
}>;

export interface TypeArgumentedNode {
    /**
     * Gets all the type arguments of the node.
     */
    getTypeArguments(): TypeNode[];
    /**
     * Adds a type argument.
     * @param argumentText - Argument text to add.
     */
    addTypeArgument(argumentText: string): TypeNode;
    /**
     * Adds type arguments.
     * @param argumentTexts - Argument texts to add.
     */
    addTypeArguments(argumentTexts: string[]): TypeNode[];
    /**
     * Inserts a type argument.
     * @param index - Index to insert at.
     * @param argumentText - Argument text to insert.
     */
    insertTypeArgument(index: number, argumentText: string): TypeNode;
    /**
     * Inserts type arguments.
     * @param index - Index to insert at.
     * @param argumentTexts - Argument texts to insert.
     */
    insertTypeArguments(index: number, argumentTexts: string[]): TypeNode[];
    /**
     * Removes a type argument.
     * @param typeArg - Type argument to remove.
     */
    removeTypeArgument(typeArg: Node): this;
    /**
     * Removes a type argument.
     * @param index - Index to remove.
     */
    removeTypeArgument(index: number): this;
}

export declare function TypeArgumentedNode<T extends Constructor<TypeArgumentedNodeExtensionType>>(Base: T): Constructor<TypeArgumentedNode> & T;

export declare type TypedNodeExtensionType = Node<ts.Node & {
    type?: ts.TypeNode;
}>;

export interface TypedNode {
    /**
     * Gets the type node or undefined if none exists.
     */
    getTypeNode(): TypeNode | undefined;
    /**
     * Gets the type node or throws if none exists.
     */
    getTypeNodeOrThrow(): TypeNode;
    /**
     * Sets the type.
     * @param writerFunction - Writer function to set the type with.
     */
    setType(writerFunction: WriterFunction): this;
    /**
     * Sets the type.
     * @param text - Text to set the type to.
     */
    setType(text: string): this;
    /**
     * Removes the type.
     */
    removeType(): this;
}

export declare function TypedNode<T extends Constructor<TypedNodeExtensionType>>(Base: T): Constructor<TypedNode> & T;

export declare type TypeElementMemberedNodeExtensionType = Node<ts.Node & {
    members: ts.TypeElement[];
}>;

export interface TypeElementMemberedNode {
    /**
     * Add construct signature.
     * @param structure - Structure representing the construct signature.
     */
    addConstructSignature(structure: ConstructSignatureDeclarationStructure): ConstructSignatureDeclaration;
    /**
     * Add construct signatures.
     * @param structures - Structures representing the construct signatures.
     */
    addConstructSignatures(structures: ConstructSignatureDeclarationStructure[]): ConstructSignatureDeclaration[];
    /**
     * Insert construct signature.
     * @param index - Index to insert at.
     * @param structure - Structure representing the construct signature.
     */
    insertConstructSignature(index: number, structure: ConstructSignatureDeclarationStructure): ConstructSignatureDeclaration;
    /**
     * Insert construct signatures.
     * @param index - Index to insert at.
     * @param structures - Structures representing the construct signatures.
     */
    insertConstructSignatures(index: number, structures: ConstructSignatureDeclarationStructure[]): ConstructSignatureDeclaration[];
    /**
     * Gets the first construct signature by a find function.
     * @param findFunction - Function to find the construct signature by.
     */
    getConstructSignature(findFunction: (member: ConstructSignatureDeclaration) => boolean): ConstructSignatureDeclaration | undefined;
    /**
     * Gets the first construct signature by a find function or throws if not found.
     * @param findFunction - Function to find the construct signature by.
     */
    getConstructSignatureOrThrow(findFunction: (member: ConstructSignatureDeclaration) => boolean): ConstructSignatureDeclaration;
    /**
     * Gets the interface construct signatures.
     */
    getConstructSignatures(): ConstructSignatureDeclaration[];
    /**
     * Add call signature.
     * @param structure - Structure representing the call signature.
     */
    addCallSignature(structure: CallSignatureDeclarationStructure): CallSignatureDeclaration;
    /**
     * Add call signatures.
     * @param structures - Structures representing the call signatures.
     */
    addCallSignatures(structures: CallSignatureDeclarationStructure[]): CallSignatureDeclaration[];
    /**
     * Insert call signature.
     * @param index - Index to insert at.
     * @param structure - Structure representing the call signature.
     */
    insertCallSignature(index: number, structure: CallSignatureDeclarationStructure): CallSignatureDeclaration;
    /**
     * Insert call signatures.
     * @param index - Index to insert at.
     * @param structures - Structures representing the call signatures.
     */
    insertCallSignatures(index: number, structures: CallSignatureDeclarationStructure[]): CallSignatureDeclaration[];
    /**
     * Gets the first call signature by a find function.
     * @param findFunction - Function to find the call signature by.
     */
    getCallSignature(findFunction: (member: CallSignatureDeclaration) => boolean): CallSignatureDeclaration | undefined;
    /**
     * Gets the first call signature by a find function or throws if not found.
     * @param findFunction - Function to find the call signature by.
     */
    getCallSignatureOrThrow(findFunction: (member: CallSignatureDeclaration) => boolean): CallSignatureDeclaration;
    /**
     * Gets the interface call signatures.
     */
    getCallSignatures(): CallSignatureDeclaration[];
    /**
     * Add index signature.
     * @param structure - Structure representing the index signature.
     */
    addIndexSignature(structure: IndexSignatureDeclarationStructure): IndexSignatureDeclaration;
    /**
     * Add index signatures.
     * @param structures - Structures representing the index signatures.
     */
    addIndexSignatures(structures: IndexSignatureDeclarationStructure[]): IndexSignatureDeclaration[];
    /**
     * Insert index signature.
     * @param index - Index to insert at.
     * @param structure - Structure representing the index signature.
     */
    insertIndexSignature(index: number, structure: IndexSignatureDeclarationStructure): IndexSignatureDeclaration;
    /**
     * Insert index signatures.
     * @param index - Index to insert at.
     * @param structures - Structures representing the index signatures.
     */
    insertIndexSignatures(index: number, structures: IndexSignatureDeclarationStructure[]): IndexSignatureDeclaration[];
    /**
     * Gets the first index signature by a find function.
     * @param findFunction - Function to find the index signature by.
     */
    getIndexSignature(findFunction: (member: IndexSignatureDeclaration) => boolean): IndexSignatureDeclaration | undefined;
    /**
     * Gets the first index signature by a find function or throws if not found.
     * @param findFunction - Function to find the index signature by.
     */
    getIndexSignatureOrThrow(findFunction: (member: IndexSignatureDeclaration) => boolean): IndexSignatureDeclaration;
    /**
     * Gets the interface index signatures.
     */
    getIndexSignatures(): IndexSignatureDeclaration[];
    /**
     * Add method.
     * @param structure - Structure representing the method.
     */
    addMethod(structure: MethodSignatureStructure): MethodSignature;
    /**
     * Add methods.
     * @param structures - Structures representing the methods.
     */
    addMethods(structures: MethodSignatureStructure[]): MethodSignature[];
    /**
     * Insert method.
     * @param index - Index to insert at.
     * @param structure - Structure representing the method.
     */
    insertMethod(index: number, structure: MethodSignatureStructure): MethodSignature;
    /**
     * Insert methods.
     * @param index - Index to insert at.
     * @param structures - Structures representing the methods.
     */
    insertMethods(index: number, structures: MethodSignatureStructure[]): MethodSignature[];
    /**
     * Gets the first method by name.
     * @param name - Name.
     */
    getMethod(name: string): MethodSignature | undefined;
    /**
     * Gets the first method by a find function.
     * @param findFunction - Function to find the method by.
     */
    getMethod(findFunction: (member: MethodSignature) => boolean): MethodSignature | undefined;
    /**
     * Gets the first method by name or throws if not found.
     * @param name - Name.
     */
    getMethodOrThrow(name: string): MethodSignature;
    /**
     * Gets the first method by a find function or throws if not found.
     * @param findFunction - Function to find the method by.
     */
    getMethodOrThrow(findFunction: (member: MethodSignature) => boolean): MethodSignature;
    /**
     * Gets the interface method signatures.
     */
    getMethods(): MethodSignature[];
    /**
     * Add property.
     * @param structure - Structure representing the property.
     */
    addProperty(structure: PropertySignatureStructure): PropertySignature;
    /**
     * Add properties.
     * @param structures - Structures representing the properties.
     */
    addProperties(structures: PropertySignatureStructure[]): PropertySignature[];
    /**
     * Insert property.
     * @param index - Index to insert at.
     * @param structure - Structure representing the property.
     */
    insertProperty(index: number, structure: PropertySignatureStructure): PropertySignature;
    /**
     * Insert properties.
     * @param index - Index to insert at.
     * @param structures - Structures representing the properties.
     */
    insertProperties(index: number, structures: PropertySignatureStructure[]): PropertySignature[];
    /**
     * Gets the first property by name.
     * @param name - Name.
     */
    getProperty(name: string): PropertySignature | undefined;
    /**
     * Gets the first property by a find function.
     * @param findFunction - Function to find the property by.
     */
    getProperty(findFunction: (member: PropertySignature) => boolean): PropertySignature | undefined;
    /**
     * Gets the first property by name or throws if not found.
     * @param name - Name.
     */
    getPropertyOrThrow(name: string): PropertySignature;
    /**
     * Gets the first property by a find function or throws if not found.
     * @param findFunction - Function to find the property by.
     */
    getPropertyOrThrow(findFunction: (member: PropertySignature) => boolean): PropertySignature;
    /**
     * Gets the interface property signatures.
     */
    getProperties(): PropertySignature[];
    /**
     * Gets all the members.
     */
    getMembers(): TypeElementTypes[];
}

export declare function TypeElementMemberedNode<T extends Constructor<TypeElementMemberedNodeExtensionType>>(Base: T): Constructor<TypeElementMemberedNode> & T;

export declare type TypeParameteredNodeExtensionType = Node<ts.Node & {
    typeParameters?: ts.NodeArray<ts.TypeParameterDeclaration>;
}>;

export interface TypeParameteredNode {
    /**
     * Gets a type parameter or undefined if it doesn't exist.
     * @param name - Name of the parameter.
     */
    getTypeParameter(name: string): TypeParameterDeclaration | undefined;
    /**
     * Gets a type parameter or undefined if it doesn't exist.
     * @param findFunction - Function to use to find the type parameter.
     */
    getTypeParameter(findFunction: (declaration: TypeParameterDeclaration) => boolean): TypeParameterDeclaration | undefined;
    /**
     * Gets a type parameter or throws if it doesn't exist.
     * @param name - Name of the parameter.
     */
    getTypeParameterOrThrow(name: string): TypeParameterDeclaration;
    /**
     * Gets a type parameter or throws if it doesn't exist.
     * @param findFunction - Function to use to find the type parameter.
     */
    getTypeParameterOrThrow(findFunction: (declaration: TypeParameterDeclaration) => boolean): TypeParameterDeclaration;
    /**
     * Gets the type parameters.
     */
    getTypeParameters(): TypeParameterDeclaration[];
    /**
     * Adds a type parameter.
     * @param structure - Structure of the type parameter.
     */
    addTypeParameter(structure: TypeParameterDeclarationStructure): TypeParameterDeclaration;
    /**
     * Adds type parameters.
     * @param structures - Structures of the type parameters.
     */
    addTypeParameters(structures: TypeParameterDeclarationStructure[]): TypeParameterDeclaration[];
    /**
     * Inserts a type parameter.
     * @param index - Index to insert at. Specify a negative index to insert from the reverse.
     * @param structure - Structure of the type parameter.
     */
    insertTypeParameter(index: number, structure: TypeParameterDeclarationStructure): TypeParameterDeclaration;
    /**
     * Inserts type parameters.
     * @param index - Index to insert at. Specify a negative index to insert from the reverse.
     * @param structures - Structures of the type parameters.
     */
    insertTypeParameters(index: number, structures: TypeParameterDeclarationStructure[]): TypeParameterDeclaration[];
}

export declare function TypeParameteredNode<T extends Constructor<TypeParameteredNodeExtensionType>>(Base: T): Constructor<TypeParameteredNode> & T;

export declare type UnwrappableNodeExtensionType = Node;

export interface UnwrappableNode {
    /**
     * Replaces the node's text with its body's statements.
     */
    unwrap(): void;
}

export declare function UnwrappableNode<T extends Constructor<UnwrappableNodeExtensionType>>(Base: T): Constructor<UnwrappableNode> & T;

export declare type InitializerExpressionableExtensionType = Node<ts.Node & {
    initializer?: ts.Expression;
}>;

export interface InitializerExpressionableNode extends InitializerGetExpressionableNode, InitializerSetExpressionableNode {
}

export declare function InitializerExpressionableNode<T extends Constructor<InitializerExpressionableExtensionType>>(Base: T): Constructor<InitializerExpressionableNode> & T;

export declare type InitializerGetExpressionableExtensionType = Node<ts.Node & {
    initializer?: ts.Expression;
}>;

export interface InitializerGetExpressionableNode {
    /**
     * Gets if node has an initializer.
     */
    hasInitializer(): boolean;
    /**
     * Gets the initializer.
     */
    getInitializer(): Expression | undefined;
    /**
     * Gets the initializer if it's a certain kind or throws.
     */
    getInitializerIfKindOrThrow<TKind extends SyntaxKind>(kind: TKind): KindToExpressionMappings[TKind];
    /**
     * Gets the initializer if it's a certain kind.
     */
    getInitializerIfKind<TKind extends SyntaxKind>(kind: TKind): KindToExpressionMappings[TKind] | undefined;
    /**
     * Gets the initializer or throw.
     */
    getInitializerOrThrow(): Expression;
}

export declare function InitializerGetExpressionableNode<T extends Constructor<InitializerGetExpressionableExtensionType>>(Base: T): Constructor<InitializerGetExpressionableNode> & T;

export declare type InitializerSetExpressionableExtensionType = Node<ts.Node & {
    initializer?: ts.Expression;
}> & InitializerGetExpressionableNode;

export interface InitializerSetExpressionableNode {
    /**
     * Removes the initailizer.
     */
    removeInitializer(): this;
    /**
     * Sets the initializer.
     * @param text - New text to set for the initializer.
     */
    setInitializer(text: string): this;
    /**
     * Sets the initializer using a writer function.
     * @param writerFunction - Function to write the initializer with.
     */
    setInitializer(writerFunction: WriterFunction): this;
}

export declare function InitializerSetExpressionableNode<T extends Constructor<InitializerSetExpressionableExtensionType>>(Base: T): Constructor<InitializerSetExpressionableNode> & T;

export declare type BindingNamedNodeExtensionType = Node<ts.Declaration & {
    name: ts.BindingName;
}>;

export interface BindingNamedNode extends BindingNamedNodeSpecific, ReferenceFindableNode {
}

export declare function BindingNamedNode<T extends Constructor<BindingNamedNodeExtensionType>>(Base: T): Constructor<BindingNamedNode> & T;

export interface BindingNamedNodeSpecific {
    /**
     * Gets the declaration's name node.
     */
    getNameNode(): Identifier;
    /**
     * Gets the declaration's name as a string.
     */
    getName(): string;
    /**
     * Renames the name.
     * @param text - New name.
     */
    rename(text: string): this;
}

export declare type DeclarationNamedNodeExtensionType = Node<ts.NamedDeclaration>;

export interface DeclarationNamedNode extends DeclarationNamedNodeSpecific, ReferenceFindableNode {
}

export declare function DeclarationNamedNode<T extends Constructor<DeclarationNamedNodeExtensionType>>(Base: T): Constructor<DeclarationNamedNode> & T;

export interface DeclarationNamedNodeSpecific {
    /**
     * Gets the name node.
     */
    getNameNode(): Identifier | undefined;
    /**
     * Gets the name node or throws an error if it doesn't exists.
     */
    getNameNodeOrThrow(): Identifier;
    /**
     * Gets the name.
     */
    getName(): string | undefined;
    /**
     * Gets the name or throws if it doens't exist.
     */
    getNameOrThrow(): string;
    /**
     * Renames the name.
     * @param text - Text to set as the name.
     */
    rename(text: string): this;
}

export declare type NameableNodeExtensionType = Node<ts.Node & {
    name?: ts.Identifier;
}>;

export interface NameableNode extends NameableNodeSpecific, ReferenceFindableNode {
}

export declare function NameableNode<T extends Constructor<NameableNodeExtensionType>>(Base: T): Constructor<NameableNode> & T;

export interface NameableNodeSpecific {
    /**
     * Gets the name node if it exists.
     */
    getNameNode(): Identifier | undefined;
    /**
     * Gets the name node if it exists, or throws.
     */
    getNameNodeOrThrow(): Identifier;
    /**
     * Gets the name if it exists.
     */
    getName(): string | undefined;
    /**
     * Gets the name if it exists, or throws.
     */
    getNameOrThrow(): string;
    /**
     * Renames the name or sets the name if it doesn't exist.
     * @param newName - New name.
     */
    rename(newName: string): this;
}

export declare type NamedNodeExtensionType = Node<ts.Node & {
    name: ts.Identifier;
}>;

export interface NamedNode extends NamedNodeSpecific, ReferenceFindableNode {
}

export declare function NamedNode<T extends Constructor<NamedNodeExtensionType>>(Base: T): Constructor<NamedNode> & T;

export interface NamedNodeSpecific {
    /**
     * Gets the name node.
     */
    getNameNode(): Identifier;
    /**
     * Gets the name.
     */
    getName(): string;
    /**
     * Renames the name.
     * @param newName - New name.
     */
    rename(newName: string): this;
}

export declare function NamedNodeInternal<T extends Constructor<NamedNodeExtensionType>>(Base: T): Constructor<NamedNodeSpecific> & T;

export declare type PropertyNamedNodeExtensionType = Node<ts.Node & {
    name: ts.PropertyName;
}>;

export interface PropertyNamedNode extends PropertyNamedNodeSpecific, ReferenceFindableNode {
}

export declare function PropertyNamedNode<T extends Constructor<PropertyNamedNodeExtensionType>>(Base: T): Constructor<PropertyNamedNode> & T;

export interface PropertyNamedNodeSpecific {
    getNameNode(): PropertyName;
    getName(): string;
    rename(text: string): this;
}

export declare type ReferenceFindableNodeExtensionType = Node<ts.Node & {
    name?: ts.PropertyName | ts.BindingName;
}>;

export interface ReferenceFindableNode {
    /**
     * Finds the references of the definition of the node.
     */
    findReferences(): ReferencedSymbol[];
    /**
     * Finds the nodes that reference the definition of the node.
     */
    findReferencesAsNodes(): Node[];
    /**
     * Gets the nodes that reference the definition of the node.
     * @deprecated Use `findReferencesAsNodes()`
     */
    getReferencingNodes(): Node[];
}

export declare function ReferenceFindableNode<T extends Constructor<ReferenceFindableNodeExtensionType>>(Base: T): Constructor<ReferenceFindableNode> & T;

export declare type AbstractableNodeExtensionType = Node & ModifierableNode;

export interface AbstractableNode {
    /**
     * Gets if the node is abstract.
     */
    isAbstract(): boolean;
    /**
     * Gets the abstract keyword or undefined if it doesn't exist.
     */
    getAbstractKeyword(): Node | undefined;
    /**
     * Gets the abstract keyword or throws if it doesn't exist.
     */
    getAbstractKeywordOrThrow(): Node;
    /**
     * Sets if the node is abstract.
     * @param isAbstract - If it should be abstract or not.
     */
    setIsAbstract(isAbstract: boolean): this;
}

export declare function AbstractableNode<T extends Constructor<AbstractableNodeExtensionType>>(Base: T): Constructor<AbstractableNode> & T;

export declare type ClassPropertyTypes = PropertyDeclaration | GetAccessorDeclaration | SetAccessorDeclaration;

export declare type ClassInstancePropertyTypes = ClassPropertyTypes | ParameterDeclaration;

export declare type ClassInstanceMemberTypes = MethodDeclaration | ClassInstancePropertyTypes;

export declare type ClassStaticPropertyTypes = PropertyDeclaration | GetAccessorDeclaration | SetAccessorDeclaration;

export declare type ClassStaticMemberTypes = MethodDeclaration | ClassStaticPropertyTypes;

export declare type ClassMemberTypes = MethodDeclaration | PropertyDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | ConstructorDeclaration;

declare const ClassDeclarationBase: (new (...args: any[]) => ChildOrderableNode) & (new (...args: any[]) => TextInsertableNode) & (new (...args: any[]) => ImplementsClauseableNode) & (new (...args: any[]) => HeritageClauseableNode) & (new (...args: any[]) => DecoratableNode) & (new (...args: any[]) => TypeParameteredNode) & (new (...args: any[]) => NamespaceChildableNode) & (new (...args: any[]) => JSDocableNode) & (new (...args: any[]) => AmbientableNode) & (new (...args: any[]) => AbstractableNode) & (new (...args: any[]) => ExportableNode) & (new (...args: any[]) => ModifierableNode) & (new (...args: any[]) => NameableNode) & typeof Statement;

export declare class ClassDeclaration extends ClassDeclarationBase<ts.ClassDeclaration> {
    /**
     * Fills the node from a structure.
     * @param structure - Structure to fill.
     */
    fill(structure: Partial<ClassDeclarationStructure>): this;
    /**
     * Sets the extends expression.
     * @param text - Text to set as the extends expression.
     */
    setExtends(text: string): this;
    /**
     * Removes the extends expression, if it exists.
     */
    removeExtends(): this;
    /**
     * Gets the extends expression or throws if it doesn't exist.
     */
    getExtendsOrThrow(): ExpressionWithTypeArguments;
    /**
     * Gets the extends expression or returns undefined if it doesn't exist.
     */
    getExtends(): ExpressionWithTypeArguments | undefined;
    /**
     * Adds a constructor.
     * @param structure - Structure of the constructor.
     */
    addConstructor(structure?: ConstructorDeclarationStructure): ConstructorDeclaration;
    /**
     * Adds constructors.
     * @param structures - Structures of the constructor.
     */
    addConstructors(structures: ConstructorDeclarationStructure[]): ConstructorDeclaration[];
    /**
     * Inserts a constructor.
     * @param index - Index to insert at.
     * @param structure - Structure of the constructor.
     */
    insertConstructor(index: number, structure?: ConstructorDeclarationStructure): ConstructorDeclaration;
    /**
     * Inserts constructors.
     * @param index - Index to insert at.
     * @param structures - Structures of the constructor.
     */
    insertConstructors(index: number, structures: ConstructorDeclarationStructure[]): ConstructorDeclaration[];
    /**
     * Gets the constructor declarations.
     */
    getConstructors(): ConstructorDeclaration[];
    /**
     * Add get accessor.
     * @param structure - Structure representing the get accessor.
     */
    addGetAccessor(structure: GetAccessorDeclarationStructure): GetAccessorDeclaration;
    /**
     * Add properties.
     * @param structures - Structures representing the properties.
     */
    addGetAccessors(structures: GetAccessorDeclarationStructure[]): GetAccessorDeclaration[];
    /**
     * Insert get accessor.
     * @param index - Index to insert at.
     * @param structure - Structure representing the get accessor.
     */
    insertGetAccessor(index: number, structure: GetAccessorDeclarationStructure): GetAccessorDeclaration;
    /**
     * Insert properties.
     * @param index - Index to insert at.
     * @param structures - Structures representing the properties.
     */
    insertGetAccessors(index: number, structures: GetAccessorDeclarationStructure[]): GetAccessorDeclaration[];
    /**
     * Add set accessor.
     * @param structure - Structure representing the set accessor.
     */
    addSetAccessor(structure: SetAccessorDeclarationStructure): SetAccessorDeclaration;
    /**
     * Add properties.
     * @param structures - Structures representing the properties.
     */
    addSetAccessors(structures: SetAccessorDeclarationStructure[]): SetAccessorDeclaration[];
    /**
     * Insert set accessor.
     * @param index - Index to insert at.
     * @param structure - Structure representing the set accessor.
     */
    insertSetAccessor(index: number, structure: SetAccessorDeclarationStructure): SetAccessorDeclaration;
    /**
     * Insert properties.
     * @param index - Index to insert at.
     * @param structures - Structures representing the properties.
     */
    insertSetAccessors(index: number, structures: SetAccessorDeclarationStructure[]): SetAccessorDeclaration[];
    /**
     * Add property.
     * @param structure - Structure representing the property.
     */
    addProperty(structure: PropertyDeclarationStructure): PropertyDeclaration;
    /**
     * Add properties.
     * @param structures - Structures representing the properties.
     */
    addProperties(structures: PropertyDeclarationStructure[]): PropertyDeclaration[];
    /**
     * Insert property.
     * @param index - Index to insert at.
     * @param structure - Structure representing the property.
     */
    insertProperty(index: number, structure: PropertyDeclarationStructure): PropertyDeclaration;
    /**
     * Insert properties.
     * @param index - Index to insert at.
     * @param structures - Structures representing the properties.
     */
    insertProperties(index: number, structures: PropertyDeclarationStructure[]): PropertyDeclaration[];
    /**
     * Gets the first instance property by name.
     * @param name - Name.
     */
    getInstanceProperty(name: string): ClassInstancePropertyTypes | undefined;
    /**
     * Gets the first instance property by a find function.
     * @param findFunction - Function to find an instance property by.
     */
    getInstanceProperty(findFunction: (prop: ClassInstancePropertyTypes) => boolean): ClassInstancePropertyTypes | undefined;
    /**
     * Gets the first instance property by name or throws if not found.
     * @param name - Name.
     */
    getInstancePropertyOrThrow(name: string): ClassInstancePropertyTypes;
    /**
     * Gets the first instance property by a find function or throws if not found.
     * @param findFunction - Function to find an instance property by.
     */
    getInstancePropertyOrThrow(findFunction: (prop: ClassInstancePropertyTypes) => boolean): ClassInstancePropertyTypes;
    /**
     * Gets the class instance property declarations.
     */
    getInstanceProperties(): ClassInstancePropertyTypes[];
    /**
     * Gets the first static property by name.
     * @param name - Name.
     */
    getStaticProperty(name: string): ClassStaticPropertyTypes | undefined;
    /**
     * Gets the first static property by a find function.
     * @param findFunction - Function to find a static property by.
     */
    getStaticProperty(findFunction: (prop: ClassStaticPropertyTypes) => boolean): ClassStaticPropertyTypes | undefined;
    /**
     * Gets the first static property by name or throws if not found.
     * @param name - Name.
     */
    getStaticPropertyOrThrow(name: string): ClassStaticPropertyTypes;
    /**
     * Gets the first static property by a find function. or throws if not found.
     * @param findFunction - Function to find a static property by.
     */
    getStaticPropertyOrThrow(findFunction: (prop: ClassStaticPropertyTypes) => boolean): ClassStaticPropertyTypes;
    /**
     * Gets the class instance property declarations.
     */
    getStaticProperties(): ClassStaticPropertyTypes[];
    /**
     * Gets the first property declaration by name.
     * @param name - Name.
     */
    getProperty(name: string): PropertyDeclaration | undefined;
    /**
     * Gets the first property declaration by a find function.
     * @param findFunction - Function to find a property declaration by.
     */
    getProperty(findFunction: (property: PropertyDeclaration) => boolean): PropertyDeclaration | undefined;
    /**
     * Gets the first property declaration by name or throws if it doesn't exist.
     * @param name - Name.
     */
    getPropertyOrThrow(name: string): PropertyDeclaration;
    /**
     * Gets the first property declaration by a find function or throws if it doesn't exist.
     * @param findFunction - Function to find a property declaration by.
     */
    getPropertyOrThrow(findFunction: (property: PropertyDeclaration) => boolean): PropertyDeclaration;
    /**
     * Gets the class property declarations regardless of whether it's an instance of static property.
     */
    getProperties(): PropertyDeclaration[];
    /**
     * Gets the first get accessor declaration by name.
     * @param name - Name.
     */
    getGetAccessor(name: string): GetAccessorDeclaration | undefined;
    /**
     * Gets the first get accessor declaration by a find function.
     * @param findFunction - Function to find a get accessor declaration by.
     */
    getGetAccessor(findFunction: (getAccessor: GetAccessorDeclaration) => boolean): GetAccessorDeclaration | undefined;
    /**
     * Gets the first get accessor declaration by name or throws if it doesn't exist.
     * @param name - Name.
     */
    getGetAccessorOrThrow(name: string): GetAccessorDeclaration;
    /**
     * Gets the first get accessor declaration by a find function or throws if it doesn't exist.
     * @param findFunction - Function to find a get accessor declaration by.
     */
    getGetAccessorOrThrow(findFunction: (getAccessor: GetAccessorDeclaration) => boolean): GetAccessorDeclaration;
    /**
     * Gets the class get accessor declarations regardless of whether it's an instance of static getAccessor.
     */
    getGetAccessors(): GetAccessorDeclaration[];
    /**
     * Sets the first set accessor declaration by name.
     * @param name - Name.
     */
    getSetAccessor(name: string): SetAccessorDeclaration | undefined;
    /**
     * Sets the first set accessor declaration by a find function.
     * @param findFunction - Function to find a set accessor declaration by.
     */
    getSetAccessor(findFunction: (setAccessor: SetAccessorDeclaration) => boolean): SetAccessorDeclaration | undefined;
    /**
     * Sets the first set accessor declaration by name or throws if it doesn't exist.
     * @param name - Name.
     */
    getSetAccessorOrThrow(name: string): SetAccessorDeclaration;
    /**
     * Sets the first set accessor declaration by a find function or throws if it doesn't exist.
     * @param findFunction - Function to find a set accessor declaration by.
     */
    getSetAccessorOrThrow(findFunction: (setAccessor: SetAccessorDeclaration) => boolean): SetAccessorDeclaration;
    /**
     * Sets the class set accessor declarations regardless of whether it's an instance of static setAccessor.
     */
    getSetAccessors(): SetAccessorDeclaration[];
    /**
     * Add method.
     * @param structure - Structure representing the method.
     */
    addMethod(structure: MethodDeclarationStructure): MethodDeclaration;
    /**
     * Add methods.
     * @param structures - Structures representing the methods.
     */
    addMethods(structures: MethodDeclarationStructure[]): MethodDeclaration[];
    /**
     * Insert method.
     * @param index - Index to insert at.
     * @param structure - Structure representing the method.
     */
    insertMethod(index: number, structure: MethodDeclarationStructure): MethodDeclaration;
    /**
     * Insert methods.
     * @param index - Index to insert at.
     * @param structures - Structures representing the methods.
     */
    insertMethods(index: number, structures: MethodDeclarationStructure[]): MethodDeclaration[];
    /**
     * Gets the first method declaration by name.
     * @param name - Name.
     */
    getMethod(name: string): MethodDeclaration | undefined;
    /**
     * Gets the first method declaration by a find function.
     * @param findFunction - Function to find a method declaration by.
     */
    getMethod(findFunction: (method: MethodDeclaration) => boolean): MethodDeclaration | undefined;
    /**
     * Gets the first method declaration by name or throws if it doesn't exist.
     * @param name - Name.
     */
    getMethodOrThrow(name: string): MethodDeclaration;
    /**
     * Gets the first method declaration by a find function or throws if it doesn't exist.
     * @param findFunction - Function to find a method declaration by.
     */
    getMethodOrThrow(findFunction: (method: MethodDeclaration) => boolean): MethodDeclaration;
    /**
     * Gets the class method declarations regardless of whether it's an instance of static method.
     */
    getMethods(): MethodDeclaration[];
    /**
     * Gets the first instance method by name.
     * @param name - Name.
     */
    getInstanceMethod(name: string): MethodDeclaration | undefined;
    /**
     * Gets the first instance method by a find function.
     * @param findFunction - Function to find an instance method by.
     */
    getInstanceMethod(findFunction: (method: MethodDeclaration) => boolean): MethodDeclaration | undefined;
    /**
     * Gets the first instance method by name or throws if not found.
     * @param name - Name.
     */
    getInstanceMethodOrThrow(name: string): MethodDeclaration;
    /**
     * Gets the first instance method by a find function. or throws if not found.
     * @param findFunction - Function to find an instance method by.
     */
    getInstanceMethodOrThrow(findFunction: (method: MethodDeclaration) => boolean): MethodDeclaration;
    /**
     * Gets the class instance method declarations.
     */
    getInstanceMethods(): MethodDeclaration[];
    /**
     * Gets the first static method by name.
     * @param name - Name.
     */
    getStaticMethod(name: string): MethodDeclaration | undefined;
    /**
     * Gets the first static method by a find function.
     * @param findFunction - Function to find a static method by.
     */
    getStaticMethod(findFunction: (method: MethodDeclaration) => boolean): MethodDeclaration | undefined;
    /**
     * Gets the first static method by name or throws if not found.
     * @param name - Name.
     */
    getStaticMethodOrThrow(name: string): MethodDeclaration;
    /**
     * Gets the first static method by a find function. or throws if not found.
     * @param findFunction - Function to find a static method by.
     */
    getStaticMethodOrThrow(findFunction: (method: MethodDeclaration) => boolean): MethodDeclaration;
    /**
     * Gets the class instance method declarations.
     */
    getStaticMethods(): MethodDeclaration[];
    /**
     * Gets the first instance member by name.
     * @param name - Name.
     */
    getInstanceMember(name: string): ClassInstanceMemberTypes | undefined;
    /**
     * Gets the first instance member by a find function.
     * @param findFunction - Function to find the instance member by.
     */
    getInstanceMember(findFunction: (member: ClassInstanceMemberTypes) => boolean): ClassInstanceMemberTypes | undefined;
    /**
     * Gets the first instance member by name or throws if not found.
     * @param name - Name.
     */
    getInstanceMemberOrThrow(name: string): ClassInstanceMemberTypes;
    /**
     * Gets the first instance member by a find function. or throws if not found.
     * @param findFunction - Function to find the instance member by.
     */
    getInstanceMemberOrThrow(findFunction: (member: ClassInstanceMemberTypes) => boo